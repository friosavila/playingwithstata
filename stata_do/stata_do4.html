<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.335">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Playing With Stata - The IV-Probit: margins and ml</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../stata_do/stata_do1.html" rel="next">
<link href="../stata_do/stata_do3.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-LCL2C8L3JH"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-LCL2C8L3JH', { 'anonymize_ip': true});
</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../WeeMee.jpg" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Playing With Stata</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../stataviz/index.html">
 <span class="menu-text">Stata Viz</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../stata_do/index.html" aria-current="page">
 <span class="menu-text">Stata Do’s Ado’s</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../app_metrics/index.html">
 <span class="menu-text">Applied econometrics</span></a>
  </li>  
  <li class="dropdown-header">
 <span class="menu-text">Odds and Ends</span></li>
  <li class="nav-item">
    <a class="nav-link" href="../chatgpt.html">
 <span class="menu-text">Fun with ChatGPT</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about.html">
 <span class="menu-text">about</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../cv.html">
 <span class="menu-text">cv &amp; Papers</span></a>
  </li>  
</ul>
              <div class="quarto-toggle-container">
                  <a href="" class="quarto-reader-toggle nav-link" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
              </div>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title">The IV-Probit: <code>margins</code> and <code>ml</code></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../stata_do/index.html" class="sidebar-item-text sidebar-link">Stata Programming</a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">Stata Do</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../stata_do/stata_do2.html" class="sidebar-item-text sidebar-link">How to Bootstrap</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../stata_do/stata_do3.html" class="sidebar-item-text sidebar-link">Linear Regression via MLE</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../stata_do/stata_do4.html" class="sidebar-item-text sidebar-link active">The IV-Probit: <code>margins</code> and <code>ml</code></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../stata_do/stata_do1.html" class="sidebar-item-text sidebar-link">Using Quarto for Stata dynamic documents</a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#the-setup" id="toc-the-setup" class="nav-link" data-scroll-target="#the-setup">The Setup</a></li>
  <li><a href="#the-actual-estimation" id="toc-the-actual-estimation" class="nav-link" data-scroll-target="#the-actual-estimation">The actual estimation</a></li>
  <li><a href="#the-log-likelihood-function" id="toc-the-log-likelihood-function" class="nav-link" data-scroll-target="#the-log-likelihood-function">The Log Likelihood function</a></li>
  <li><a href="#the-predict-program" id="toc-the-predict-program" class="nav-link" data-scroll-target="#the-predict-program">The predict program</a></li>
  <li><a href="#a-story-of-marginal-effects" id="toc-a-story-of-marginal-effects" class="nav-link" data-scroll-target="#a-story-of-marginal-effects">A Story of marginal effects</a>
  <ul class="collapse">
  <li><a href="#stata-13" id="toc-stata-13" class="nav-link" data-scroll-target="#stata-13">Stata 13</a></li>
  </ul></li>
  <li><a href="#stata-14.1" id="toc-stata-14.1" class="nav-link" data-scroll-target="#stata-14.1">Stata 14.1</a></li>
  <li><a href="#stata-16" id="toc-stata-16" class="nav-link" data-scroll-target="#stata-16">Stata 16</a></li>
  <li><a href="#one-last-change." id="toc-one-last-change." class="nav-link" data-scroll-target="#one-last-change.">One last change.</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-body" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title d-none d-lg-block">The IV-Probit: <code>margins</code> and <code>ml</code></h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
<p class="subtitle lead">Story of marginal effects</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>In previous articles, I have shown how to use the <code>margins</code> command after <code>ml</code> for the linear regression model (assuming normality) and the probit model. Today, I’ll provide another example for a more complex case: a two-equation model estimation, specifically the “IVprobit,” or instrumental variable probit.</p>
<p>This model has gained notoriety due to its inconsistent estimated marginal effects, which have been the subject of multiple threads on Statalist. The issue comes from different versions of “marginal effects” produced by <code>margins</code> in different Stata versions. Each version is correct from a computational standpoint, but not always consistent with common sense.</p>
<p>My assessment, backed up by discussions with colleagues, is that:</p>
<ul>
<li><p>Stata 13 estimated the correct marginal effects for the IVprobit MLE but not for the two-step approach.</p></li>
<li><p>Stata 14 and 15 estimated the Full Information Marginal Effect, which is technically correct but contradicts common sense. Prof Wooldridge has extensively discussed this issue and advocates for either MLE or two-step marginal effects.</p></li>
<li><p>Stata 16 released an update that now produces something equivalent to the two-step marginal effect for MLE estimation, likely due to recent discussions.</p></li>
</ul>
<p>No changes that I am aware came in Stata 17, except perhaps that we still do not have marginal effects for a two-step approach.</p>
<p>Without further ado, let me present my own version of how to estimate an IVprobit model and how to set up the predict program. I’ll also explain why there were so many types of marginal effects in use.</p>
</section>
<section id="the-setup" class="level2">
<h2 class="anchored" data-anchor-id="the-setup">The Setup</h2>
<p>First thing first. Unless you already have this program saved somewhere in your accesible ado files (most likely the “ado/personal” folder), make sure to have the following program in memory. It will allow you to add or modify information to e(), which is where all estimation commands store information.</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode stata code-with-copy"><code class="sourceCode stata"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">clear</span> <span class="ot">all</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">program</span> adde, <span class="kw">eclass</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">ereturn</span> <span class="ot">`0'</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s start with some Econometrics 101: The IVprobit model is a nonlinear model that is useful when you have a binary dependent variable (0-1) but one or more of your controls suffer from endogeneity. In this case, you want to estimate the “probability of success (y=1)” given a set of characteristics, but the characteristics of insterest is a continuous but endogenous explanatory.</p>
<p>Now, when a variable is endogenous, we cannot estimate the model and interpret the results as causal effects. This happens because changes in the endogenous variable can happen at the same time as changes in unobserved components. Therefore, if the outcome changes, we cannot tell if it is because the endogenous variable changed or because the unobservables changed (as they are, after all, correlated).</p>
<p>To deal unobserved confounders, we have two options:</p>
<ol type="1">
<li><p>We can use instruments to isolate the exogenous variation of the variable of interest (using the 2SLS approach, for example)</p></li>
<li><p>Use the instruments to obtain an approximation of the endogenous component that we can control for directly (Control function approach).</p></li>
</ol>
<p>In fact, IV-probit is the application of the latter: a control function approach.</p>
<p>Formally, IVprobit model can be written as follows:</p>
<p><span id="eq-q1"><span class="math display">\[
y_2 = z_1 \delta_1 + z_2 \delta_2 + u_2
\tag{1}\]</span></span></p>
<p><span id="eq-q2"><span class="math display">\[
y_1^*= z_1 \beta_1 + y_2 \beta_2 + u_1
\tag{2}\]</span></span></p>
<p><span class="math display">\[
y_1 = 1(y_1^*&gt;0)
\]</span></p>
<p>where the errors <span class="math inline">\(u_1,u_2\)</span> follow a bivariate normal distribution:</p>
<p><span class="math display">\[
\begin{pmatrix} u_1 \\ u_2 \end{pmatrix} \sim Normal  \begin{pmatrix}  \begin{matrix} 0 \\ 0 \end{matrix},
\begin{matrix} 1 &amp; \rho \sigma_2\\ \rho \sigma_2 &amp; \sigma^2_2 \end{matrix} \end{pmatrix}
\]</span></p>
<p>In this model <span class="math inline">\(z_1\)</span> and <span class="math inline">\(z_2\)</span> are exogenous variables, <span class="math inline">\(z_2\)</span> is a set of instruments, and <span class="math inline">\(y_2\)</span> is a continuous but endogenous variable in the model. Finally we do not observe the latent variable <span class="math inline">\(y_1^*\)</span>, but instead observe <span class="math inline">\(y_1\)</span> which only takes values of 0 or 1. So how do we estimate this model?? by parts!</p>
<p>The <a href="#eq-q1">Equation&nbsp;1</a> can be estimated directly, because it is a function of exogenous variables only. Thus, we could estimate that equation using standard OLS (as ivprobit-two-step does), or via MLE assuming the normality of the errors.</p>
<p>The one that requires more attention is <a href="#eq-q2">Equation&nbsp;2</a>. We know that <span class="math inline">\(corr(y_2,u_1)\)</span> is different from zero, which is the cause of the endogeneity of <span class="math inline">\(y_2\)</span>. We could, however, <strong>decompose</strong> <span class="math inline">\(u1\)</span> into two parts. One that contains the endogenous component, and one that is exogenous and uncorrelated with all other variables.</p>
<p>To do this, we should first recall that if <span class="math inline">\(u_1, u_2\)</span> follow a bivariate normal distribution, then, conditional on <span class="math inline">\(u_2\)</span>, <span class="math inline">\(u_1\)</span> will have the following distribution:</p>
<p><span id="eq-q3s"><span class="math display">\[
u_1 \sim N\left(\rho \frac{u_2}{\sigma_2}, {1-\rho^2} \right)
\tag{3}\]</span></span></p>
<p>which implies, we could write <span class="math inline">\(u_1\)</span> as follows:</p>
<p><span id="eq-q3"><span class="math display">\[
u_1 = \rho \frac{ u_2}{ \sigma_2} + v_1
\tag{4}\]</span></span></p>
<p>In this case, <span class="math inline">\(v_1\)</span> will be, by construction, uncorrelated with <span class="math inline">\(u_2\)</span> or with <span class="math inline">\(y_2\)</span>. So, we if substitute <a href="#eq-q3">Equation&nbsp;4</a> into <a href="#eq-q1">Equation&nbsp;1</a>, we obtain:</p>
<p><span id="eq-q4"><span class="math display">\[
y_1^* = z_1 \beta_1 + y_2 \beta_2 + \rho \frac{ u_2}{ \sigma_2} + v_1
\tag{5}\]</span></span></p>
<p>This equation can now be estimated directly, assuming we observe <span class="math inline">\(u_2\)</span>. However, to be estimated with a probit model, we also need to rescale the equation so that the re-scaled error <span class="math inline">\(v_1\)</span> has a variance of 1.</p>
<p>Based on <a href="#eq-q3s">Equation&nbsp;3</a>, we know <span class="math inline">\(v_1\)</span> has a variance of <span class="math inline">\(1-\rho^2\)</span>, so we just need to divide all terms in <a href="#eq-q4">Equation&nbsp;5</a> by <span class="math inline">\(\sqrt{1-\rho^2}\)</span> and estimating the following model (or its simplification) using standard probit model. <span id="eq-q5"><span class="math display">\[
\frac{y^*_1}{\sqrt{1-\rho^2}} =
    z_1 \frac{\beta_1}{\sqrt{1-\rho^2}} +
    y_2 \frac{\beta_2}{\sqrt{1-\rho^2}} +
    \frac{\rho}{\sqrt{1-\rho^2}} \frac{u_2}{\sigma_2} +
    \frac{v_1}{\sqrt{1-\rho^2}}
\tag{6}\]</span></span> <span id="eq-q6"><span class="math display">\[
y^{**}_1 = z_1 \beta^r_1 + y_2 \beta^r_2 +
    \theta \frac{u_2}{\sigma_2} +   v_1
\tag{7}\]</span></span></p>
<p>What is the difference between using either equation?. I would argue none, as long as you know how to estimate the standard errors from the system.</p>
</section>
<section id="the-actual-estimation" class="level2">
<h2 class="anchored" data-anchor-id="the-actual-estimation">The actual estimation</h2>
<p>Let’s discuss the different methods that can be used to estimate the ivprobit model. There are at least three ways to do so.</p>
<p>The first method is the two-step approach. In this method, one estimates <a href="#eq-q1">Equation&nbsp;1</a> using OLS, obtains the predicted residuals, which are plugged into equation <a href="#eq-q6">Equation&nbsp;7</a>. This can be estimated using a simple probit model.</p>
<p>This method has two problems:</p>
<ul>
<li><p>It only provides estimates for the “rescaled” coefficients, not the structural coefficients.</p></li>
<li><p>It will not provide you with the correct estimation of standard errors, because it will not consider the residuals are carrying over errors from the first step.</p></li>
</ul>
<p>Some textbooks suggest that doing so is a <strong>simple</strong> application of the <strong>delta method</strong>, or use <strong>bootstrap</strong>. But, the fact of the matter, is that you need to take into account that the residuals from <a href="#eq-q1">Equation&nbsp;1</a> are estimated not the true residuals <span class="math inline">\(u_2\)</span>.</p>
<p>The second method is to estimate <a href="#eq-q1">Equation&nbsp;1</a> and <a href="#eq-q4">Equation&nbsp;5</a> simultaneously using full information maximum likelihood. This imposes the assumption that the errors follow a bivariate normal distribution, and allows you to obtain estimates for the structural parameters, in addition to the “link” parameters <span class="math inline">\(\sigma_2\)</span> and <span class="math inline">\(\rho\)</span>, providing correct standard errors.</p>
<p>Under this strategy, the contribution of a single observation to the likelihood function becomes:</p>
<p><span class="math display">\[
\begin{aligned}
L_i &amp;= L_i^1*L_i^2 \\
L_i^1 &amp;= \phi(y_2,z_1\delta_1 + z_2 \delta_2, \sigma_2) \\
\hat P(y_1|.) &amp;= \Phi \left( \frac{ z_1 \beta_1 + y_2 \beta_2 + \rho \frac{y_2 -z_1 \delta_1 - z_2 \delta_2}{\sigma_2}}
{\sqrt{1-\rho^2}} \right) \\
L^2_i &amp; = P(y_1|.)^{y_1} * (1-P(y_1|.))^{1-y_1}
\end{aligned}
\]</span></p>
<p>Notice that instead of <strong><em>plugging in</em></strong> <span class="math inline">\(\hat u_2\)</span> in the probit equation, I explicitly add <span class="math inline">\(y_2 -z_1 \delta_1 - z_2 \delta_2\)</span>. This allows to explicilty account for the measurement errors of the first stage.</p>
<p>There is a third option, which I will call <strong>two-step-mle</strong>. I call it this way, because the ivprobit will be estimated using <a href="#eq-q1">Equation&nbsp;1</a> and <a href="#eq-q6">Equation&nbsp;7</a>. However, I call it MLE, because both equations are estimated simultaneously using MLE:</p>
<p><span id="eq-q8"><span class="math display">\[
\begin{aligned}
L_i &amp;= L_i^1*L_i^2 \\
L_i^1 &amp;= \phi(y_2,z_1\delta_1 + z_2 \delta_2, \sigma_2) \\
\hat P(y_1|.) &amp;=  \Phi \left(  z_1 \beta^r_1 + y_2 \beta^r_2 + \theta \frac {y_2 -z_1 \delta_1 - z_2 \delta_2}{\sigma_2} \right) \\
L^2_i &amp; = P(y_1|.)^{y_1} * (1-P(y_1|.))^{1-y_1}
\end{aligned}
\tag{8}\]</span></span></p>
<p>The difference with the standard FIML, is that only rescaled coefficients are estimated, and that the link between both equation is <span class="math inline">\(\theta\)</span> not <span class="math inline">\(\rho\)</span>. Nevertheless, For this simplified example, both equations identify exactly the same model. If you are interested in this type of use of -ml- see my paper <span class="citation" data-cites="rios-avila_standard-error_2018">Rios-Avila and Canavire-Bacarreza (<a href="#ref-rios-avila_standard-error_2018" role="doc-biblioref">2018</a>)</span>.</p>
<p>Compared to the usual two-step approach, however, because the model is estimated simultaneously, the standard errors of all coefficients are correctly estimated, without further calculations (no delta method nor bootstrap).</p>
<p>One last thing to notice in this model. First, there is a close relationship between <span class="math inline">\(\theta\)</span> and <span class="math inline">\(\rho\)</span>, which will affect the rescaled parameters: <span class="math display">\[
\theta = \frac{\rho}{\sqrt{1-\rho^2}} \rightarrow \rho =  \frac{\theta}{\sqrt{1+\theta^2}}
\]</span> <span class="math display">\[
\beta = \beta^r \times \sqrt{1-\rho^2} = \frac{\beta^r}{\sqrt{1+\theta^2}}
\]</span></p>
</section>
<section id="the-log-likelihood-function" class="level2">
<h2 class="anchored" data-anchor-id="the-log-likelihood-function">The Log Likelihood function</h2>
<p>While I have shown that using FIML and two-step-ml will provide the same results, I’ll stick with the two-step approach, as it allows me to derive marginal effects telling the story of what happened to -margins- through different Stata versions.</p>
<p>The following program defines this the log-likelihood function for the IV probit, using the two-step approach (<a href="#eq-q8">Equation&nbsp;8</a>), using the following walk-through for the specification:</p>
<ul>
<li><code>xb</code> will contain all the exogenous variables <span class="math inline">\(z_1\)</span> plus the endogenous variable <span class="math inline">\(y_2\)</span></li>
<li><code>zb</code> will contain all the exogenous variables <span class="math inline">\(z_1\)</span> and the instruments <span class="math inline">\(z_2\)</span></li>
</ul>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode stata code-with-copy"><code class="sourceCode stata"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">program</span> myivprobit_2sls</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">args</span> lnf <span class="kw">xb</span> theta zb lnsigma</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">qui</span> {</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">local</span> y1 <span class="ot">$ML_y1</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">local</span> y2 <span class="ot">$ML_y2</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">local</span> u2 (<span class="ot">`y2'</span>-<span class="ot">`zb'</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">tempvar</span> xb_zb p1 p0</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">gen</span> <span class="kw">double</span> <span class="ot">`xb_zb'</span>= <span class="ot">`xb'</span>+<span class="ot">`theta'</span>*((<span class="ot">`u2'</span>)/<span class="fu">exp</span>(<span class="ot">`lnsigma'</span>)) </span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">gen</span> <span class="kw">double</span> <span class="ot">`p1'</span>   = <span class="fu">normal</span>( <span class="ot">`xb_zb'</span>)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">gen</span> <span class="kw">double</span> <span class="ot">`p0'</span>   = <span class="fu">normal</span>(-<span class="ot">`xb_zb'</span>)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">tempvar</span> lnf1 lnf2</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">gen</span> <span class="kw">double</span> <span class="ot">`lnf1'</span>  = <span class="fu">log</span>(<span class="fu">normalden</span>(<span class="ot">`y2'</span>, <span class="ot">`zb'</span>, <span class="fu">exp</span>(<span class="ot">`lnsigma'</span>)))</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">gen</span> <span class="kw">double</span> <span class="ot">`lnf2'</span> = <span class="fu">log</span>(<span class="ot">`p1'</span>) <span class="kw">if</span> <span class="ot">`y1'</span>==1</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="kw">replace</span>    <span class="ot">`lnf2'</span> = <span class="fu">log</span>(<span class="ot">`p0'</span>) <span class="kw">if</span> <span class="ot">`y1'</span>==0</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">replace</span> <span class="ot">`lnf'</span> = <span class="ot">`lnf1'</span> + <span class="ot">`lnf2'</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span>    </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="the-predict-program" class="level2">
<h2 class="anchored" data-anchor-id="the-predict-program">The predict program</h2>
<p>So finally, the part that will be a bit more controversial. The prediction of the probability of success!.</p>
<p>The reason why this is controversial is because there are two candidates to identify this expression.</p>
<p>The first candidate relates to the structural <a href="#eq-q2">Equation&nbsp;2</a>. Basically, if we can estimate the unscaled coefficients, the predicted outcome could be identified by:</p>
<p><span class="math display">\[
P(y_1=1| z_1 , y_2) = \Phi \left( z_1 \beta_1 + y_2 \beta_2  \right)
\]</span></p>
<p>or if one prefers the version based on rescaled coefficients: <span class="math display">\[
P(y_1=1| z_1 , y_2) = \Phi \left( z_1 \beta^r_1 * {\sqrt{1-\rho^2}} + y_2 \beta^r_2 * {\sqrt{1-\rho^2}} \right)
\]</span></p>
<p>Thus, marginal effects can be obtained by analyzing either one of these equations alone. Standard errors for this expression can be identified directly only if we estimate the structural equation using FIML, or using the rescaled coefficients, making sure standard errors are calculated acounting for the estimation errors of the first stage.</p>
<p>The second option relates to estimate the marginal effects using <a href="#eq-q6">Equation&nbsp;7</a>:</p>
<p><span id="eq-q6a"><span class="math display">\[
P(y_1=1| z_1 , y_2, \hat{u}_2 ) = \Phi \left( z_1 \beta^r_1 + y_2 \beta^r_2 + \theta \hat{u}_2 \right)
\tag{9}\]</span></span></p>
<p>However, because <span class="math inline">\(hat u_2\)</span> is never observed, it is usually recommended to average (but not ignore) the impact of <span class="math inline">\(\hat u_2\)</span> on the equation:</p>
<p><span id="eq-q6b"><span class="math display">\[
P(y_1=1| z_1 , y_2) = E \left( \Phi \left( z_1 \beta^r_1 + y_2 \beta^r_2 + \theta \hat{u}_2 \right)| z_1, y_2 \right)
\tag{10}\]</span></span></p>
<p>The bottom line: If one uses the two-step approach, marginal effects could be estimated assuming <span class="math inline">\(\hat u_2\)</span> is just another exogenous variable in the model. The difficulty would be obtaining the correct estimation of standard errors.</p>
<p>So lets write these two options into a “predict” program.</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode stata code-with-copy"><code class="sourceCode stata"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">program</span> myivprobit_p</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">syntax</span> newvarname [<span class="kw">if</span>] [<span class="kw">in</span>] , [ pr1 pr2  *]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="st">"`pr1'`pr2'"</span> ==<span class="st">""</span> {</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">ml_p</span> <span class="ot">`0'</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">tokenize</span> <span class="ot">`e(depvar)'</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">local</span> y1  <span class="ot">`1'</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">local</span> y2  <span class="ot">`2'</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">marksample</span> touse, novarlist</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> <span class="st">"`pr1'"</span> !=<span class="st">""</span>  {</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">tempvar</span> <span class="kw">xb</span> zb theta lnsigma</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        _predict <span class="kw">double</span> <span class="ot">`xb'</span>   , <span class="kw">eq</span>(#1)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        _predict <span class="kw">double</span> <span class="ot">`theta'</span>, <span class="kw">eq</span>(#2)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        _predict <span class="kw">double</span> <span class="ot">`zb'</span>   , <span class="kw">eq</span>(#3) </span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        _predict <span class="kw">double</span> <span class="ot">`lnsigma'</span>, <span class="kw">eq</span>(#4)       </span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">gen</span> <span class="ot">`typlist'</span> <span class="ot">`varlist'</span> = <span class="co">///</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>            <span class="fu">normal</span>(<span class="ot">`xb'</span>+<span class="ot">`theta'</span>*(<span class="ot">`y2'</span>-<span class="ot">`zb'</span>)/<span class="fu">exp</span>(<span class="ot">`lnsigma'</span>)) <span class="kw">if</span> <span class="ot">`touse'</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">label</span> <span class="kw">var</span> <span class="ot">`varlist'</span> <span class="st">"P(y=1|X) two-step"</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    }       </span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="kw">if</span> <span class="st">"`pr2'"</span>!=<span class="st">""</span> {</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">tempvar</span> <span class="kw">xb</span> zb theta lnsigma</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        _predict <span class="kw">double</span> <span class="ot">`xb'</span> , <span class="kw">eq</span>(#1)</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        _predict <span class="kw">double</span> <span class="ot">`theta'</span>  , <span class="kw">eq</span>(#2)</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">gen</span> <span class="ot">`typlist'</span> <span class="ot">`varlist'</span> = <span class="co">///</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>            <span class="fu">normal</span>(<span class="ot">`xb'</span>/<span class="fu">sqrt</span>(1+<span class="ot">`theta'</span>^2)) <span class="kw">if</span> <span class="ot">`touse'</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">label</span> <span class="kw">var</span> <span class="ot">`varlist'</span> <span class="st">"P(y=1|X) FIML"</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The first option <code>pr1</code> will estimate the predicted probability as if the model were estimated using the two-step approach, whereas the second will estimate the predicted probability based on the structural equation.</p>
<p>Alright, so lets estimate the model and compare the results with the built-in ivprobit command:</p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode stata code-with-copy"><code class="sourceCode stata"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">clear</span>  </span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">webuse</span> laborsup</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">global</span>  y1   fem_work</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">global</span>  z1   fem_educ   kids  </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">global</span>  y2   other_inc</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">global</span>  z2   male_educ   </span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>*Built <span class="kw">in</span> command:</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="kw">ivprobit</span> <span class="ot">$y1</span>  <span class="ot">$z1</span> (<span class="ot">$y2</span> = <span class="ot">$z2</span>), <span class="kw">two</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Checking reduced-form model...</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Two-step probit with endogenous regressors        Number of obs   =        500
                                                  Wald chi2(3)    =      93.97
                                                  Prob &gt; chi2     =     0.0000
</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>------------------------------------------------------------------------------
             | Coefficient  Std. err.      z    P&gt;|z|     [95% conf. interval]</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>-------------+----------------------------------------------------------------
   other_inc |</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>   -.058473   .0093364    -6.26   0.000    -.0767719    -.040174
    fem_educ |    .227437   .0281628     8.08   0.000     .1722389     .282635
        kids |  -.1961748   .0496323    -3.95   0.000    -.2934522   -.0988973
       _cons |   .3956061   .4982649     0.79   0.427    -.5809752    1.372187
------------------------------------------------------------------------------</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Wald test of exogeneity: chi2(1) = 6.50                   Prob &gt; chi2 = 0.0108
Instrumented: other_inc
 Instruments: fem_educ kids male_educ</code></pre>
</div>
</div>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode stata code-with-copy"><code class="sourceCode stata"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>*my <span class="kw">ivprobit</span> <span class="kw">two</span>-step</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">ml</span> <span class="kw">model</span> lf myivprobit_2sls (<span class="ot">$y1</span> = <span class="ot">$z1</span>  <span class="ot">$y2</span> ) <span class="co">///</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>         (theta:) (<span class="ot">$y2</span> = <span class="ot">$z1</span> <span class="ot">$z2</span>  ) (lnsigma:) , <span class="co">///</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>         <span class="kw">technique</span>(<span class="kw">nr</span> <span class="kw">bhhh</span>) init(lnsigma:<span class="dt">_cons</span> = 2.81 ) <span class="kw">maximize</span> <span class="kw">nolog</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">ml</span> <span class="kw">display</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
                                                        Number of obs =    500
                                                        Wald chi2(3)  =  94.01
Log likelihood = -2368.2062                             Prob &gt; chi2   = 0.0000

------------------------------------------------------------------------------
             | Coefficient  Std. err.      z    P&gt;|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
eq1          |
    fem_educ |    .227437   .0281561     8.08   0.000     .1722519     .282622
        kids |  -.1961748   .0496179    -3.95   0.000    -.2934242   -.0989254
   other_inc |  -.0584729   .0093339    -6.26   0.000    -.0767671   -.0401788
       _cons |   .3956051   .4981099     0.79   0.427    -.5806724    1.371883
-------------+----------------------------------------------------------------
theta        |
       _cons |   .4008081   .1626174     2.46   0.014     .0820838    .7195323
-------------+----------------------------------------------------------------
eq3          |
    fem_educ |   .3351867   .2825972     1.19   0.236    -.2186937     .889067
        kids |   .8329056   .5475666     1.52   0.128    -.2403052    1.906116
   male_educ |   2.845253    .282746    10.06   0.000     2.291081    3.399425
       _cons |   9.872559   5.029193     1.96   0.050     .0155214     19.7296
-------------+----------------------------------------------------------------
lnsigma      |
       _cons |   2.813383   .0316228    88.97   0.000     2.751404    2.875363
------------------------------------------------------------------------------</code></pre>
</div>
</div>
<p>You can see right away that except for differences attributed to rounding errors and degrees of freedom, the results are virtually the same. It is also reasuring to see that the results are also the same when we compared ivprobit-mle and the rescaled coefficients:</p>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode stata code-with-copy"><code class="sourceCode stata"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>*FIML</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">ivprobit</span> <span class="ot">$y1</span>  <span class="ot">$z1</span> (<span class="ot">$y2</span> = <span class="ot">$z2</span>), <span class="kw">ml</span> <span class="kw">nolog</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Probit model with endogenous regressors                 Number of obs =    500
                                                        Wald chi2(3)  = 163.88
Log likelihood = -2368.2062                             Prob &gt; chi2   = 0.0000

-------------------------------------------------------------------------------
              | Coefficient  Std. err.      z    P&gt;|z|     [95% conf. interval]
--------------+----------------------------------------------------------------
    other_inc |  -.0542756   .0060854    -8.92   0.000    -.0662028   -.0423485
     fem_educ |    .211111   .0268648     7.86   0.000     .1584569    .2637651
         kids |  -.1820929   .0478267    -3.81   0.000    -.2758315   -.0883542
        _cons |   .3672086   .4480724     0.82   0.412    -.5109971    1.245414
--------------+----------------------------------------------------------------
corr(e.othe~c,|
   e.fem_work)|   .3720375   .1300518                      .0946562    .5958136
sd(e.other_~c)|   16.66621   .5270318                      15.66461    17.73186
-------------------------------------------------------------------------------</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Wald test of exogeneity (corr = 0): chi2(1) = 6.70        Prob &gt; chi2 = 0.0096
Instrumented: other_inc
 Instruments: fem_educ kids male_educ</code></pre>
</div>
</div>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode stata code-with-copy"><code class="sourceCode stata"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>*my <span class="kw">ivprobit</span> <span class="kw">two</span>-step</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">ml</span> <span class="kw">model</span> lf myivprobit_2sls (<span class="ot">$y1</span> = <span class="ot">$z1</span>  <span class="ot">$y2</span> )  (theta:) (<span class="ot">$y2</span> = <span class="ot">$z1</span> <span class="ot">$z2</span>  ) (lnsigma:) , <span class="co">///</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">technique</span>(<span class="kw">nr</span> <span class="kw">bhhh</span>)   init(lnsigma:<span class="dt">_cons</span> = 2.81 ) <span class="kw">maximize</span> <span class="kw">nolog</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>adde <span class="kw">local</span> <span class="kw">predict</span> myivprobit_p                 </span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="kw">est</span> <span class="kw">store</span> myivp</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>*with rescaled coefficients:</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="kw">nlcom</span>   (other_inc: _b[other_inc]/<span class="fu">sqrt</span>(1+_b[theta:<span class="dt">_cons</span>]^2)) <span class="co">///</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>        (fem_educ: _b[fem_educ]/<span class="fu">sqrt</span>(1+_b[theta:<span class="dt">_cons</span>]^2)) <span class="co">///</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        (kids: _b[kids]/<span class="fu">sqrt</span>(1+_b[theta:<span class="dt">_cons</span>]^2)) <span class="co">///</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>        (cons: _b[<span class="dt">_cons</span>]/<span class="fu">sqrt</span>(1+_b[theta:<span class="dt">_cons</span>]^2)) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
   other_inc: _b[other_inc]/sqrt(1+_b[theta:_cons]^2)
    fem_educ: _b[fem_educ]/sqrt(1+_b[theta:_cons]^2)
        kids: _b[kids]/sqrt(1+_b[theta:_cons]^2)
        cons: _b[_cons]/sqrt(1+_b[theta:_cons]^2)</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
------------------------------------------------------------------------------
             | Coefficient  Std. err.      z    P&gt;|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
   other_inc |  -.0542756   .0060854    -8.92   0.000    -.0662027   -.0423485
    fem_educ |    .211111   .0268648     7.86   0.000      .158457    .2637651
        kids |  -.1820929   .0478267    -3.81   0.000    -.2758316   -.0883543
        cons |   .3672077   .4480724     0.82   0.412    -.5109982    1.245414
------------------------------------------------------------------------------</code></pre>
</div>
</div>
<p>Again, showing exactly the same results</p>
</section>
<section id="a-story-of-marginal-effects" class="level2">
<h2 class="anchored" data-anchor-id="a-story-of-marginal-effects">A Story of marginal effects</h2>
<p>Let me now walk you through the Story of marginal effects with ivprobit.</p>
<section id="stata-13" class="level3">
<h3 class="anchored" data-anchor-id="stata-13">Stata 13</h3>
<p>Back in Stata 13, marginal effects for IV probit were estimated using the structural equation coeffients: <span class="math display">\[
P(y_1=1|z_1,y_2)=\Phi(z_1\beta_1+y_2\beta_2)
\]</span></p>
<p>So that marginal effects were defined as: <span class="math display">\[
\begin{aligned}
\frac{\partial P(y_1=1|.)}{\partial z_1} = \phi ( z_1 \beta_1 + y_2 \beta_2  ) \beta_1 \\
\frac{\partial P(y_1=1|.)}{\partial y_2} = \phi ( z_1 \beta_1 + y_2 \beta_2  ) \beta_2
\end{aligned}
\]</span></p>
<div class="callout-note callout callout-style-default callout-captioned">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-caption-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>As you may have noticed, I’m rewritting few of my older posts using Quarto. So, I can only use Stata17 dynamically. Because of that the code you will see below will not be reproducible, unless you have the same Stata version</p>
</div>
</div>
<p>If you have access to Stata 13, you will be able to reproduce the following output:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode stata code-with-copy"><code class="sourceCode stata"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>margins, <span class="kw">dydx</span>(*) <span class="kw">predict</span>(pr)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>Average marginal <span class="kw">effects</span>                          Number <span class="kw">of</span> <span class="kw">obs</span>   =        500</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>Model <span class="kw">VCE</span>    : OIM</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>Expression   : Probability <span class="kw">of</span> positive outcome, <span class="kw">predict</span>(pr)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>dy/dx <span class="fu">w</span>.<span class="fu">r</span>.t. : other_inc fem_educ kids male_educ</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>------------------------------------------------------------------------------</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>             |            Delta-method</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>             |      dy/dx   Std. Err.      z    P&gt;|z|     [95% Conf. Interval]</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>-------------+----------------------------------------------------------------</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>   other_inc |   -.014015   .0009836   -14.25   0.000    -.0159428   -.0120872</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    fem_educ |   .0545129   .0066007     8.26   0.000     .0415758      .06745</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>        kids |  -.0470199   .0123397    -3.81   0.000    -.0712052   -.0228346</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>   male_educ |          0  (omitted)</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>------------------------------------------------------------------------------</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This marginal effects are emulated using pr2 after myivprobit:</p>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode stata code-with-copy"><code class="sourceCode stata"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">est</span> <span class="kw">restore</span> myivp</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>margins, <span class="kw">dydx</span>(*) <span class="kw">predict</span>(pr2) <span class="kw">force</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>(results myivp are active now)
note: prediction is a function of possibly stochastic quantities other than
      e(b).</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Average marginal effects                                   Number of obs = 500
Model VCE: OIM

Expression: P(y=1|X) FIML, predict(pr2)
dy/dx wrt:  fem_educ kids other_inc male_educ

------------------------------------------------------------------------------
             |            Delta-method
             |      dy/dx   std. err.      z    P&gt;|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
    fem_educ |   .0545129   .0066003     8.26   0.000     .0415766    .0674493
        kids |  -.0470199   .0123394    -3.81   0.000    -.0712047   -.0228351
   other_inc |   -.014015   .0009837   -14.25   0.000    -.0159431   -.0120869
   male_educ |          0  (omitted)
------------------------------------------------------------------------------</code></pre>
</div>
</div>
<p>You will see output from margins also include <code>male_educ</code> in the list of exogenous variables. This happens because it is an explanatory variable for at least one equation in the model (first). However, because this variable is not included in the second equation, it has a no effect on it.</p>
</section>
</section>
<section id="stata-14.1" class="level2">
<h2 class="anchored" data-anchor-id="stata-14.1">Stata 14.1</h2>
<p>When we reached Stata 14.1, a change was introduced in how probabilities were calculated after ivprobit. As it says in the “whatsnew” material, the new formulation would take into account endogeneity.</p>
<p>Specifically, they use what I call the 2sls predicted probabilities, following equation (5) wth the caveat that <span class="math inline">\(\hat u_2\)</span> was substituted by <span class="math inline">\(y_2 - z_1 \delta_1 -z2\delta_2\)</span>:</p>
<p><span id="eq-q12"><span class="math display">\[
P(y_1=1|z_1,y_2,z_2) =\Phi \left(
    \frac{z_1 \beta_1 + y_2 \beta_2 + \rho \frac{y_2 - z_1 \delta_1 - z_2 \delta_2}{\sigma_2}}
    {\sqrt{1-\rho^2}}   \right)
\tag{11}\]</span></span></p>
<p>While the two equations above are basically the same, they have important differences when marginal effects are estimated by software. Specifically, the probability of sucess is now a function of <span class="math inline">\(z_2\)</span>!.</p>
<p>So let me explain first what Stata 14.1, did. To estimate marginal effects, partial derivatives were based on <a href="#eq-q12">Equation&nbsp;11</a>:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{\partial P(y=1|.)}{\partial z_1} &amp;=
  \phi(.)*\left( \frac{\beta_1}{\sqrt{1-\rho^2}}  
  -\frac{\rho}{\sqrt{1-\rho^2}} * \frac{\delta_1}{\sigma_2} \right)  \\
   \frac{\partial P(y=1|.)}{\partial z_2} &amp;=
    \phi(.)*\left( 0
  -\frac{\rho}{\sqrt{1-\rho^2}} * \frac{\delta_2}{\sigma_2} \right)  \\
\frac{\partial P(y=1|.)}{\partial y_2} &amp;=
    \phi(.)*\left( \frac{\beta_2}{\sqrt{1-\rho^2}}  
    +\frac{1}{\sqrt{1-\rho^2}} * \frac{1}{\sigma_2} \right)    
\end{aligned}
\]</span></p>
<p>From the technical point of view, these partial derivatives are correct, since they are capturing both the direct and indirect effects of all variables on the probability of success. Something similar to total, rather than partial, derivative.</p>
<p>The problem, however, is that this assumes we could actually observe how the unobserved component changes when other variables change. Standard regression analysis, however, would say that these unobserved components should be considered as fixed, and instead one should estimate marginal effects averaging over the unobserved factors. Thus, the second term on each one of the above derivatives should be zero.</p>
<p>Nevertheless, if you try estimating marginal effects with Stata 14.2, you will get the following result:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode stata code-with-copy"><code class="sourceCode stata"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>margins, <span class="kw">dydx</span>(*) <span class="kw">predict</span>(pr)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>Average marginal <span class="kw">effects</span>                        Number <span class="kw">of</span> <span class="kw">obs</span>     =        500</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>Model <span class="kw">VCE</span>    : OIM</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>Expression   : Probability <span class="kw">of</span> positive outcome, <span class="kw">predict</span>(pr)</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>dy/dx <span class="fu">w</span>.<span class="fu">r</span>.t. : other_inc fem_educ kids male_educ</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>------------------------------------------------------------------------------</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>             |            Delta-method</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>             |      dy/dx   Std. Err.      z    P&gt;|z|     [95% Conf. Interval]</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>-------------+----------------------------------------------------------------</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>   other_inc |  -.0097802   .0014994    -6.52   0.000     -.012719   -.0068414</span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>    fem_educ |   .0623273    .007099     8.78   0.000     .0484135     .076241</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>        kids |  -.0614265   .0139446    -4.41   0.000    -.0887574   -.0340956</span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>   male_educ |  -.0194406   .0022103    -8.80   0.000    -.0237728   -.0151084</span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>------------------------------------------------------------------------------</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To replicate this using <code>myivprobit</code>, I would estimate marginal effects using option <code>pr1</code>, requesting derivates to be estimated without the <strong>chain rule</strong> (<code>nochain</code>). This makes sure that one takes into account the effect of all changes in <span class="math inline">\(y_2, z_1\)</span> and <span class="math inline">\(z_2\)</span> on the predicted outcome <span class="math inline">\(P(y=1|.)\)</span>:</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode stata code-with-copy"><code class="sourceCode stata"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">est</span> <span class="kw">restore</span> myivp</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>margins, <span class="kw">dydx</span>(*) <span class="kw">predict</span>(pr1) <span class="kw">force</span> nochain</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>(results myivp are active now)
note: prediction is a function of possibly stochastic quantities other than
      e(b).</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Average marginal effects                                   Number of obs = 500
Model VCE: OIM
</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Expression: P(y=1|X) two-step, predict(pr1)
dy/dx wrt:  fem_educ kids other_inc male_educ

------------------------------------------------------------------------------
             |            Delta-method
             |      dy/dx   std. err.      z    P&gt;|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
    fem_educ |   .0623273   .0060316    10.33   0.000     .0505055     .074149
        kids |  -.0614265   .0128383    -4.78   0.000    -.0865891   -.0362639
   other_inc |  -.0097802   .0009828    -9.95   0.000    -.0117065   -.0078539
   male_educ |  -.0194406   .0074886    -2.60   0.009    -.0341181   -.0047631
------------------------------------------------------------------------------</code></pre>
</div>
</div>
</section>
<section id="stata-16" class="level2">
<h2 class="anchored" data-anchor-id="stata-16">Stata 16</h2>
<p>The earlier version of Stata 16 came with very similar problems as the ones mentioned above. However, due in part to an earlier version of this article, in November of 2020, Stata made a correction in how marginal effects were estimated for <code>ivprobit</code> as well as other related commands (see update 19nov2020).</p>
<p>In this update, they change the default option and now produces the correct marginal effects, assuming the predicted errors are fixed.</p>
<p>Let’s take a closer look at the findings. First, it appears that Stata 14, 15, and early 16 versions were unintentionally estimating a partial effect that accounted for a second-order effect through the first stage regression. While this might have a negligible effect on the exogenous variables, it could have a considerable impact on the endogenous variable of interest, resulting in some people reporting negative marginal effects even when the estimated coefficient was positive. Additionally, the instrument, in this case <code>male_educ</code>, would also appear in the output, capturing only a second-order effect on the outcome of interest.</p>
<p>However, after a lively discussion on Statalist, including input from Prof.&nbsp;Wooldridge, it was revealed that Stata (and margins) was incorrectly estimating marginal effects. As shown here, partial derivatives were being estimated through the first and second equations, leading to incorrect results.</p>
<p>Prof.&nbsp;Wooldridge recommended a manual two-step approach for estimating marginal effects, with standard errors obtained via bootstrap, using <a href="#eq-q6a">Equation&nbsp;9</a> to estimate the partial effects. This makes a difference because we will be making the explicit assumption that <span class="math inline">\(\hat u_2\)</span> does not change when the other variables change. This will modify the partial effects to the following:</p>
<p><span class="math display">\[
\begin{aligned}
\frac{\partial P(y=1|.)}{\partial z_1} &amp;=
  \phi(.)*\left( \frac{\beta_1}{\sqrt{1-\rho^2}} \right)   \\
   \frac{\partial P(y=1|.)}{\partial z_2} &amp;=
    \phi(.)* 0  \\
  \frac{\partial P(y=1|.)}{\partial y_2} &amp;=
    \phi(.)* \left( \frac{\beta_2}{\sqrt{1-\rho^2}}  \right)     
\end{aligned}
\]</span></p>
<p>The differences with the “structural” marginal effects are that the evaluation of <span class="math inline">\(\phi(.)\)</span> includes the predicted values of the errors (<span class="math inline">\(\hat u_2\)</span>), and that coefficients used correspond to the two-step procedure ones (rescaled).</p>
<p>To show empirically how this works, we can compare the builtin command, with the “two-step” procedure suggested by Prof.&nbsp;Wooldridge:</p>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode stata code-with-copy"><code class="sourceCode stata"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>* <span class="kw">two</span> step procedure</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>* 1st</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="kw">qui</span>: <span class="kw">reg</span> <span class="ot">$y2</span> <span class="ot">$z1</span> <span class="ot">$z2</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="kw">predict</span> <span class="kw">double</span> u2, <span class="kw">resid</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>* 2nd</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="kw">qui</span>: <span class="kw">probit</span> <span class="ot">$y1</span> <span class="ot">$z1</span> <span class="ot">$y2</span> u2, <span class="kw">nolog</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>margins, <span class="kw">dydx</span>(*) <span class="kw">predict</span>(pr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Average marginal effects                                   Number of obs = 500
Model VCE: OIM

Expression: Pr(fem_work), predict(pr)
dy/dx wrt:  fem_educ kids other_inc u2
</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>------------------------------------------------------------------------------
             |            Delta-method
             |      dy/dx   std. err.      z    P&gt;|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
    fem_educ |   .0646175   .0060271    10.72   0.000     .0528045    .0764304
        kids |  -.0557355   .0129302    -4.31   0.000    -.0810782   -.0303929
   other_inc |  -.0166128   .0022499    -7.38   0.000    -.0210225   -.0122032
          u2 |   .0068326    .002632     2.60   0.009     .0016741    .0119912
------------------------------------------------------------------------------</code></pre>
</div>
</div>
<p>The standard errors here will not be correct, but bootstrap could be applied to obtain corrected standard errors.</p>
<p>With the correction to estimation of marginal effects pushed in Novenber of 2020, we can produce the correct point estimates for marginal effects, which follows Prof Wooldrige suggestion, and my discussion presented here.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode stata code-with-copy"><code class="sourceCode stata"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>** built-<span class="kw">in</span> command</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="kw">qui</span>:<span class="kw">ivprobit</span> <span class="ot">$y1</span>  <span class="ot">$z1</span> (<span class="ot">$y2</span> = <span class="ot">$z2</span>), <span class="kw">ml</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>margins, <span class="kw">dydx</span>(*) <span class="kw">predict</span>(pr)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>Average marginal <span class="kw">effects</span>                        Number <span class="kw">of</span> <span class="kw">obs</span>     =        500</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>Model <span class="kw">VCE</span>    : OIM</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>Expression   : Average structural <span class="kw">function</span> probabilities, <span class="kw">predict</span>(pr)</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>dy/dx <span class="fu">w</span>.<span class="fu">r</span>.t. : other_inc fem_educ kids</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>------------------------------------------------------------------------------</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>             |            Delta-method</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>             |      dy/dx   Std. Err.      z    P&gt;|z|     [95% Conf. Interval]</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>-------------+----------------------------------------------------------------</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>   other_inc |  -.0166128   .0012889   -12.89   0.000     -.019139   -.0140867</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>    fem_educ |   .0646175   .0073529     8.79   0.000      .050206     .079029</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>        kids |  -.0557355   .0144233    -3.86   0.000    -.0840047   -.0274664</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>------------------------------------------------------------------------------</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>So you can see that the two-step approach and the built-in approach now provide the same marginal effects. And since the official command estimates all coefficients simultaneously, the standard errors can be taken as correct (more on that later).</p>
<p>So how can we correct for this with our predict program. Since there is nothing to prevent margins to obtain numerical derivatives across both equations, we need to modify the specification slighly. First, we create clone copies of all variables that enter the second stage: z_1 and y_2, and use them for the model estimation:</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode stata code-with-copy"><code class="sourceCode stata"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">clonevar</span> c_other_inc = other_inc</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="kw">clonevar</span> c_fem_educ  = fem_educ</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="kw">clonevar</span> c_kids      = kids</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="kw">global</span>  y2b c_other_inc</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="kw">global</span>  z1b c_fem_educ c_kids </span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="kw">ml</span> <span class="kw">model</span> lf myivprobit_2sls (<span class="ot">$y1</span> = <span class="ot">$z1</span>  <span class="ot">$y2</span> )  (theta:) (<span class="ot">$y2b</span> = <span class="ot">$z1b</span> <span class="ot">$z2</span>  ) (lnsigma:) , <span class="co">///</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>            <span class="kw">technique</span>(<span class="kw">nr</span> <span class="kw">bhhh</span>)   init(lnsigma:<span class="dt">_cons</span> = 2.81 ) <span class="kw">maximize</span> <span class="kw">nolog</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>adde <span class="kw">local</span> <span class="kw">predict</span> myivprobit_p                 </span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="kw">est</span> sto myivp   </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The idea of using “clones” of the exogenous variables and endogenous one is to have access to the same information as the original data, but making sure they do not change when the original data changes.</p>
<p>Marginal effects can be calculated as I did before, except that I now make it explicit to request marginal effects with respect to <span class="math inline">\(z_1\)</span> and <span class="math inline">\(y_2\)</span> only.</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode stata code-with-copy"><code class="sourceCode stata"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">est</span> <span class="kw">restore</span> myivp       </span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>margins, <span class="kw">dydx</span>(<span class="ot">$z1</span> <span class="ot">$y2</span>) <span class="kw">predict</span>(pr1) <span class="kw">force</span> </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>(results myivp are active now)
note: prediction is a function of possibly stochastic quantities other than
      e(b).</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Average marginal effects                                   Number of obs = 500
Model VCE: OIM

Expression: P(y=1|X) two-step, predict(pr1)
dy/dx wrt:  fem_educ kids other_inc
</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>------------------------------------------------------------------------------
             |            Delta-method
             |      dy/dx   std. err.      z    P&gt;|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
    fem_educ |   .0646175    .006331    10.21   0.000     .0522089    .0770261
        kids |  -.0557355   .0134693    -4.14   0.000    -.0821349   -.0293362
   other_inc |  -.0166128   .0023499    -7.07   0.000    -.0212185   -.0120072
------------------------------------------------------------------------------</code></pre>
</div>
</div>
<p>And done!. We have been able to reproduce the second version, two-step, marginal effects for the instrumental variable probit model, that follows the two-step approach advocated by Prof.&nbsp;Wooldridge, and officially included in Stata 16 and above.</p>
<p>There is only one last perky detail. If you look at the marginal effect standard errors I produce with the myivprobit command, and compare it with the marginal effects the ivprobit command produces, you will notice they are different.</p>
<p>The reason for this was that, based on unofficial words from the developers, at the time:</p>
<blockquote class="blockquote">
<p>the current formulation assumes <span class="math inline">\(\rho\)</span> and <span class="math inline">\(\sigma\)</span> to be constant, when standard errors are obtained.</p>
</blockquote>
<p>While this may seem incorrect, I understand the intuition behind this idea.</p>
<p>If you recall the estimation of marginal effects from the structural equation, it is not affected by <span class="math inline">\(\rho\)</span> nor <span class="math inline">\(\sigma\)</span>. Perhaps this was one of the reasons why the estimated standard errors (Nov2020) are so similar to the ones based on the “old” structural marginal effects.</p>
<p>My own command, however, accounts for the uncertainty in these parameter. This also seems correct since two-step marginal procedures are expected to be less efficient than the Full Information counterparts.</p>
<p>Of course, if you prefer to have a tie-breaker on which one is correct, I can use a Bootstrap procedure to produce the elusive standard errors. Basically, I’ll use the manual two-step procedure, along with a 250 bootstrap repetitions, to report the results:</p>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode stata code-with-copy"><code class="sourceCode stata"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">program</span> bs_ivprobit, <span class="kw">eclass</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">reg</span> <span class="ot">$y2</span> <span class="ot">$z1</span> <span class="ot">$z2</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">capture</span> <span class="kw">drop</span> u2</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">predict</span> <span class="kw">double</span> u2, <span class="kw">resid</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">probit</span> <span class="ot">$y1</span> <span class="ot">$z1</span> <span class="ot">$y2</span> u2</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    margins, <span class="kw">dydx</span>(*) <span class="kw">predict</span>(pr) nose <span class="kw">post</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a><span class="kw">end</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a><span class="kw">bootstrap</span> , reps(250) <span class="dv">seed</span>(1) <span class="kw">nodots</span>:bs_ivprobit</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Average marginal effects                                   Number of obs = 500
                                                           Replications  = 250

------------------------------------------------------------------------------
             |   Observed   Bootstrap                         Normal-based
             | coefficient  std. err.      z    P&gt;|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
    fem_educ |   .0646175   .0058983    10.96   0.000      .053057     .076178
        kids |  -.0557355   .0138358    -4.03   0.000    -.0828532   -.0286179
   other_inc |  -.0166128   .0023778    -6.99   0.000    -.0212732   -.0119525
          u2 |   .0068326   .0027569     2.48   0.013     .0014292    .0122361
------------------------------------------------------------------------------</code></pre>
</div>
</div>
<p>In this case, it seems that the bootstrap estimates seem to favor my version of marginal effects and standard errors!</p>
</section>
<section id="one-last-change." class="level2">
<h2 class="anchored" data-anchor-id="one-last-change.">One last change.</h2>
<p>Seems my guess was correct!. In March of 2021, Stata pushed another update to Stata16. They have now changed how SE are estimated after margins, which now coincides with the experiment I started with.</p>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode stata code-with-copy"><code class="sourceCode stata"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">ivprobit</span> <span class="ot">$y1</span>  <span class="ot">$z1</span> (<span class="ot">$y2</span> = <span class="ot">$z2</span>), <span class="kw">ml</span> <span class="kw">nolog</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>margins, <span class="kw">dydx</span>(*) <span class="kw">predict</span>(pr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Probit model with endogenous regressors                 Number of obs =    500
                                                        Wald chi2(3)  = 163.88
Log likelihood = -2368.2062                             Prob &gt; chi2   = 0.0000

-------------------------------------------------------------------------------
              | Coefficient  Std. err.      z    P&gt;|z|     [95% conf. interval]
--------------+----------------------------------------------------------------
    other_inc |  -.0542756   .0060854    -8.92   0.000    -.0662028   -.0423485
     fem_educ |    .211111   .0268648     7.86   0.000     .1584569    .2637651
         kids |  -.1820929   .0478267    -3.81   0.000    -.2758315   -.0883542
        _cons |   .3672086   .4480724     0.82   0.412    -.5109971    1.245414
--------------+----------------------------------------------------------------
corr(e.othe~c,|
   e.fem_work)|   .3720375   .1300518                      .0946562    .5958136
sd(e.other_~c)|   16.66621   .5270318                      15.66461    17.73186
-------------------------------------------------------------------------------
Wald test of exogeneity (corr = 0): chi2(1) = 6.70        Prob &gt; chi2 = 0.0096
Instrumented: other_inc
 Instruments: fem_educ kids male_educ</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>
Average marginal effects                                   Number of obs = 500
Model VCE: OIM

Expression: Average structural function probabilities, predict(pr)
dy/dx wrt:  other_inc fem_educ kids

------------------------------------------------------------------------------
             |            Delta-method
             |      dy/dx   std. err.      z    P&gt;|z|     [95% conf. interval]
-------------+----------------------------------------------------------------
   other_inc |  -.0166128   .0023501    -7.07   0.000    -.0212189   -.0120068
    fem_educ |   .0646175   .0063309    10.21   0.000     .0522091    .0770258
        kids |  -.0557355   .0134692    -4.14   0.000    -.0821347   -.0293364
------------------------------------------------------------------------------</code></pre>
</div>
</div>
<p>So there is my small contribution to Stata!</p>
</section>
<section id="conclusion" class="level2">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>The command -ml- is a powerful tool that can be used to estimate single or multiple equation models, as long as the loglikelihood functions (and their inter-relations) can be properly defined.</p>
<p>-margins- is also a very flexible command that can be easily combined with -ml- to expand the estimation of marginal effects for properly defined outcomes. While the command is flexible and relatively easy to use, these properties can also be double-edge swords, if one is not aware of the mechanics behind the actual estimation of partial effects.</p>
<p>In my view, the original estimation of marginal effects after iv-probit was correct, but the changes it received in Stata 14.1 introduced what we could call a bug, that was based on solid Math. However, unless you dig deeper into what ivprobit tries to estimate, it would be difficult to say why that change produced undesirable results.</p>
<p>The updates pushed in Stata 16 made the necesary corrections following my suggestions, and now produces correct partial effects (two-step like), even adopting my comment regarding standard errors.</p>


<!-- -->


</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" role="doc-bibliography">
<div id="ref-rios-avila_standard-error_2018" class="csl-entry" role="doc-biblioentry">
Rios-Avila, Fernando, and Gustavo Canavire-Bacarreza. 2018. <span>“Standard-Error <span>Correction</span> in <span>Two</span>-Stage <span>Optimization</span> <span>Models</span>: <span>A</span> <span>Quasi</span>–Maximum <span>Likelihood</span> <span>Estimation</span> <span>Approach</span>.”</span> <em>The Stata Journal</em> 18 (1): 206–22. <a href="https://doi.org/10.1177/1536867X1801800113">https://doi.org/10.1177/1536867X1801800113</a>.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation column-body">
  <div class="nav-page nav-page-previous">
      <a href="../stata_do/stata_do3.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Linear Regression via MLE</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../stata_do/stata_do1.html" class="pagination-link">
        <span class="nav-page-text">Using Quarto for Stata dynamic documents</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb42" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "The IV-Probit: `margins` and `ml`"</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="an">subtitle:</span><span class="co"> "Story of marginal effects"</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span><span class="co"> html</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="an">code-fold:</span><span class="co"> false</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="an">bibliography:</span><span class="co"> mywork.bib</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a><span class="fu">## Introduction</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>In previous articles, I have shown how to use the <span class="in">`margins`</span> command after <span class="in">`ml`</span> for the linear regression model (assuming normality) and the probit model. Today, I'll provide another example for a more complex case: a two-equation model estimation, specifically the "IVprobit," or instrumental variable probit.</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>This model has gained notoriety due to its inconsistent estimated marginal effects, which have been the subject of multiple threads on Statalist. The issue comes from different versions of "marginal effects" produced by <span class="in">`margins`</span> in different Stata versions. Each version is correct from a computational standpoint, but not always consistent with common sense.</span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>My assessment, backed up by discussions with colleagues, is that:</span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Stata 13 estimated the correct marginal effects for the IVprobit MLE but not for the two-step approach.</span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Stata 14 and 15 estimated the Full Information Marginal Effect, which is technically correct but contradicts common sense. Prof Wooldridge has extensively discussed this issue and advocates for either MLE or two-step marginal effects.</span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Stata 16 released an update that now produces something equivalent to the two-step marginal effect for MLE estimation, likely due to recent discussions. </span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a>No changes that I am aware came in Stata 17, except perhaps that we still do not have marginal effects for a two-step approach.</span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true" tabindex="-1"></a>Without further ado, let me present my own version of how to estimate an IVprobit model and how to set up the predict program. I'll also explain why there were so many types of marginal effects in use.</span>
<span id="cb42-26"><a href="#cb42-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-27"><a href="#cb42-27" aria-hidden="true" tabindex="-1"></a><span class="fu">## The Setup</span></span>
<span id="cb42-28"><a href="#cb42-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-29"><a href="#cb42-29" aria-hidden="true" tabindex="-1"></a>First thing first. Unless you already have this program saved somewhere in your accesible ado files (most likely the "ado/personal" folder), make sure to have the following program in memory. It will allow you to add or modify information to e(), which is where all estimation commands store information.</span>
<span id="cb42-30"><a href="#cb42-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-33"><a href="#cb42-33" aria-hidden="true" tabindex="-1"></a><span class="in">```{stata}</span></span>
<span id="cb42-34"><a href="#cb42-34" aria-hidden="true" tabindex="-1"></a><span class="in">clear all</span></span>
<span id="cb42-35"><a href="#cb42-35" aria-hidden="true" tabindex="-1"></a><span class="in">program adde, eclass</span></span>
<span id="cb42-36"><a href="#cb42-36" aria-hidden="true" tabindex="-1"></a><span class="in">    ereturn `0'</span></span>
<span id="cb42-37"><a href="#cb42-37" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb42-38"><a href="#cb42-38" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-39"><a href="#cb42-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-40"><a href="#cb42-40" aria-hidden="true" tabindex="-1"></a>Let's start with some Econometrics 101: The IVprobit model is a nonlinear model that is useful when you have a binary dependent variable (0-1) but one or more of your controls suffer from endogeneity. In this case, you want to estimate the "probability of success (y=1)" given a set of characteristics, but the characteristics of insterest is a continuous but endogenous explanatory. </span>
<span id="cb42-41"><a href="#cb42-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-42"><a href="#cb42-42" aria-hidden="true" tabindex="-1"></a>Now, when a variable is endogenous, we cannot estimate the model and interpret the results as causal effects. This happens because changes in the endogenous variable can happen at the same time as changes in unobserved components. Therefore, if the outcome changes, we cannot tell if it is because the endogenous variable changed or because the unobservables changed (as they are, after all, correlated).</span>
<span id="cb42-43"><a href="#cb42-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-44"><a href="#cb42-44" aria-hidden="true" tabindex="-1"></a>To deal unobserved confounders, we have two options:</span>
<span id="cb42-45"><a href="#cb42-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-46"><a href="#cb42-46" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>We can use instruments to isolate the exogenous variation of the variable of interest (using the 2SLS approach, for example) </span>
<span id="cb42-47"><a href="#cb42-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-48"><a href="#cb42-48" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Use the instruments to obtain an approximation of the endogenous component that we can control for directly (Control function approach). </span>
<span id="cb42-49"><a href="#cb42-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-50"><a href="#cb42-50" aria-hidden="true" tabindex="-1"></a>In fact, IV-probit is the application of the latter: a control function approach.</span>
<span id="cb42-51"><a href="#cb42-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-52"><a href="#cb42-52" aria-hidden="true" tabindex="-1"></a>Formally, IVprobit model can be written as follows:</span>
<span id="cb42-53"><a href="#cb42-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-54"><a href="#cb42-54" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-55"><a href="#cb42-55" aria-hidden="true" tabindex="-1"></a>y_2 = z_1 \delta_1 + z_2 \delta_2 + u_2</span>
<span id="cb42-56"><a href="#cb42-56" aria-hidden="true" tabindex="-1"></a>$${#eq-q1}</span>
<span id="cb42-57"><a href="#cb42-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-58"><a href="#cb42-58" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-59"><a href="#cb42-59" aria-hidden="true" tabindex="-1"></a>y_1^*= z_1 \beta_1 + y_2 \beta_2 + u_1</span>
<span id="cb42-60"><a href="#cb42-60" aria-hidden="true" tabindex="-1"></a>$${#eq-q2}</span>
<span id="cb42-61"><a href="#cb42-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-62"><a href="#cb42-62" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-63"><a href="#cb42-63" aria-hidden="true" tabindex="-1"></a>y_1 = 1(y_1^*&gt;0)</span>
<span id="cb42-64"><a href="#cb42-64" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-65"><a href="#cb42-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-66"><a href="#cb42-66" aria-hidden="true" tabindex="-1"></a>where the errors $u_1,u_2$ follow a bivariate normal distribution:</span>
<span id="cb42-67"><a href="#cb42-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-68"><a href="#cb42-68" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-69"><a href="#cb42-69" aria-hidden="true" tabindex="-1"></a>\begin{pmatrix} u_1 <span class="sc">\\</span> u_2 \end{pmatrix} \sim Normal  \begin{pmatrix}  \begin{matrix} 0 <span class="sc">\\</span> 0 \end{matrix},</span>
<span id="cb42-70"><a href="#cb42-70" aria-hidden="true" tabindex="-1"></a>\begin{matrix} 1 &amp; \rho \sigma_2<span class="sc">\\</span> \rho \sigma_2 &amp; \sigma^2_2 \end{matrix} \end{pmatrix}</span>
<span id="cb42-71"><a href="#cb42-71" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-72"><a href="#cb42-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-73"><a href="#cb42-73" aria-hidden="true" tabindex="-1"></a>In this model $z_1$ and $z_2$ are exogenous variables, $z_2$ is a set of instruments, and $y_2$ is a continuous but endogenous variable in the model. Finally we do not observe the latent variable $y_1^*$, but instead observe $y_1$ which only takes values of 0 or 1. So how do we estimate this model?? by parts!</span>
<span id="cb42-74"><a href="#cb42-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-75"><a href="#cb42-75" aria-hidden="true" tabindex="-1"></a>The @eq-q1 can be estimated directly, because it is a function of exogenous variables only. Thus, we could estimate that equation using standard OLS (as ivprobit-two-step does), or via MLE assuming the normality of the errors.</span>
<span id="cb42-76"><a href="#cb42-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-77"><a href="#cb42-77" aria-hidden="true" tabindex="-1"></a>The one that requires more attention is @eq-q2. We know that $corr(y_2,u_1)$ is different from zero, which is the cause of the endogeneity of </span>
<span id="cb42-78"><a href="#cb42-78" aria-hidden="true" tabindex="-1"></a>$y_2$. We could, however, **decompose** $u1$ into two parts. One that contains the endogenous component, and one that is exogenous and uncorrelated with all other variables. </span>
<span id="cb42-79"><a href="#cb42-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-80"><a href="#cb42-80" aria-hidden="true" tabindex="-1"></a>To do this, we should first recall that if $u_1, u_2$ follow a bivariate normal distribution, then, conditional on $u_2$, $u_1$ will have the following distribution:</span>
<span id="cb42-81"><a href="#cb42-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-82"><a href="#cb42-82" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-83"><a href="#cb42-83" aria-hidden="true" tabindex="-1"></a>u_1 \sim N\left(\rho \frac{u_2}{\sigma_2}, {1-\rho^2} \right)</span>
<span id="cb42-84"><a href="#cb42-84" aria-hidden="true" tabindex="-1"></a>$${#eq-q3s}</span>
<span id="cb42-85"><a href="#cb42-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-86"><a href="#cb42-86" aria-hidden="true" tabindex="-1"></a>which implies, we could write $u_1$ as follows:</span>
<span id="cb42-87"><a href="#cb42-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-88"><a href="#cb42-88" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-89"><a href="#cb42-89" aria-hidden="true" tabindex="-1"></a>u_1 = \rho \frac{ u_2}{ \sigma_2} + v_1</span>
<span id="cb42-90"><a href="#cb42-90" aria-hidden="true" tabindex="-1"></a>$${#eq-q3}</span>
<span id="cb42-91"><a href="#cb42-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-92"><a href="#cb42-92" aria-hidden="true" tabindex="-1"></a>In this case, $v_1$ will be, by construction, uncorrelated with $u_2$ or with $y_2$. So, we if substitute @eq-q3 into @eq-q1, we obtain:</span>
<span id="cb42-93"><a href="#cb42-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-94"><a href="#cb42-94" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-95"><a href="#cb42-95" aria-hidden="true" tabindex="-1"></a>y_1^* = z_1 \beta_1 + y_2 \beta_2 + \rho \frac{ u_2}{ \sigma_2} + v_1</span>
<span id="cb42-96"><a href="#cb42-96" aria-hidden="true" tabindex="-1"></a>$${#eq-q4}</span>
<span id="cb42-97"><a href="#cb42-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-98"><a href="#cb42-98" aria-hidden="true" tabindex="-1"></a>This equation can now be estimated directly, assuming we observe $u_2$. However, to be estimated with a probit model, we also need to rescale the equation so that the re-scaled error $v_1$ has a variance of 1. </span>
<span id="cb42-99"><a href="#cb42-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-100"><a href="#cb42-100" aria-hidden="true" tabindex="-1"></a>Based on @eq-q3s, we know $v_1$ has a variance of $1-\rho^2$, so we just need to divide all terms in @eq-q4 by $\sqrt{1-\rho^2}$ and estimating the following model (or its simplification) using standard probit model.</span>
<span id="cb42-101"><a href="#cb42-101" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-102"><a href="#cb42-102" aria-hidden="true" tabindex="-1"></a>\frac{y^*_1}{\sqrt{1-\rho^2}} = </span>
<span id="cb42-103"><a href="#cb42-103" aria-hidden="true" tabindex="-1"></a>    z_1 \frac{\beta_1}{\sqrt{1-\rho^2}} + </span>
<span id="cb42-104"><a href="#cb42-104" aria-hidden="true" tabindex="-1"></a>    y_2 \frac{\beta_2}{\sqrt{1-\rho^2}} + </span>
<span id="cb42-105"><a href="#cb42-105" aria-hidden="true" tabindex="-1"></a>    \frac{\rho}{\sqrt{1-\rho^2}} \frac{u_2}{\sigma_2} +</span>
<span id="cb42-106"><a href="#cb42-106" aria-hidden="true" tabindex="-1"></a>    \frac{v_1}{\sqrt{1-\rho^2}} </span>
<span id="cb42-107"><a href="#cb42-107" aria-hidden="true" tabindex="-1"></a>$${#eq-q5}</span>
<span id="cb42-108"><a href="#cb42-108" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-109"><a href="#cb42-109" aria-hidden="true" tabindex="-1"></a>y^{**}_1 = z_1 \beta^r_1 + y_2 \beta^r_2 + </span>
<span id="cb42-110"><a href="#cb42-110" aria-hidden="true" tabindex="-1"></a>    \theta \frac{u_2}{\sigma_2} +   v_1 </span>
<span id="cb42-111"><a href="#cb42-111" aria-hidden="true" tabindex="-1"></a>$${#eq-q6}</span>
<span id="cb42-112"><a href="#cb42-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-113"><a href="#cb42-113" aria-hidden="true" tabindex="-1"></a>What is the difference between using either equation?. I would argue none, as long as you know how to estimate the standard errors from the system.</span>
<span id="cb42-114"><a href="#cb42-114" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-115"><a href="#cb42-115" aria-hidden="true" tabindex="-1"></a><span class="fu">## The actual estimation</span></span>
<span id="cb42-116"><a href="#cb42-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-117"><a href="#cb42-117" aria-hidden="true" tabindex="-1"></a>Let's discuss the different methods that can be used to estimate the ivprobit model. There are at least three ways to do so.</span>
<span id="cb42-118"><a href="#cb42-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-119"><a href="#cb42-119" aria-hidden="true" tabindex="-1"></a>The first method is the two-step approach. In this method, one estimates @eq-q1 using OLS, obtains the predicted residuals, which are plugged into equation @eq-q6. This can be estimated using a simple probit model. </span>
<span id="cb42-120"><a href="#cb42-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-121"><a href="#cb42-121" aria-hidden="true" tabindex="-1"></a>This method has two problems: </span>
<span id="cb42-122"><a href="#cb42-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-123"><a href="#cb42-123" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>It only provides estimates for the "rescaled" coefficients, not the structural coefficients. </span>
<span id="cb42-124"><a href="#cb42-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-125"><a href="#cb42-125" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>It will not provide you with the correct estimation of standard errors, because it will not consider the residuals are carrying over errors from the first step. </span>
<span id="cb42-126"><a href="#cb42-126" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-127"><a href="#cb42-127" aria-hidden="true" tabindex="-1"></a>Some textbooks suggest that doing so is a **simple** application of the **delta method**, or use **bootstrap**. But, the fact of the matter, is that you need to take into account that the residuals from @eq-q1 are estimated not the true residuals $u_2$. </span>
<span id="cb42-128"><a href="#cb42-128" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-129"><a href="#cb42-129" aria-hidden="true" tabindex="-1"></a>The second method is to estimate @eq-q1 and @eq-q4 simultaneously using full information maximum likelihood. This imposes the assumption that the errors follow a bivariate normal distribution, and allows you to obtain estimates for the structural parameters, in addition to the "link" parameters $\sigma_2$ and $\rho$, providing correct standard errors.</span>
<span id="cb42-130"><a href="#cb42-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-131"><a href="#cb42-131" aria-hidden="true" tabindex="-1"></a>Under this strategy, the contribution of a single observation to the likelihood function becomes:</span>
<span id="cb42-132"><a href="#cb42-132" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-133"><a href="#cb42-133" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-134"><a href="#cb42-134" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb42-135"><a href="#cb42-135" aria-hidden="true" tabindex="-1"></a>L_i &amp;= L_i^1*L_i^2 <span class="sc">\\</span></span>
<span id="cb42-136"><a href="#cb42-136" aria-hidden="true" tabindex="-1"></a>L_i^1 &amp;= \phi(y_2,z_1\delta_1 + z_2 \delta_2, \sigma_2) <span class="sc">\\</span></span>
<span id="cb42-137"><a href="#cb42-137" aria-hidden="true" tabindex="-1"></a>\hat P(y_1|.) &amp;= \Phi \left( \frac{ z_1 \beta_1 + y_2 \beta_2 + \rho \frac{y_2 -z_1 \delta_1 - z_2 \delta_2}{\sigma_2}}</span>
<span id="cb42-138"><a href="#cb42-138" aria-hidden="true" tabindex="-1"></a>{\sqrt{1-\rho^2}} \right) <span class="sc">\\</span></span>
<span id="cb42-139"><a href="#cb42-139" aria-hidden="true" tabindex="-1"></a>L^2_i &amp; = P(y_1|.)^{y_1} * (1-P(y_1|.))^{1-y_1}</span>
<span id="cb42-140"><a href="#cb42-140" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb42-141"><a href="#cb42-141" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-142"><a href="#cb42-142" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-143"><a href="#cb42-143" aria-hidden="true" tabindex="-1"></a>Notice that instead of ***plugging in*** $\hat u_2$ in the probit equation, I explicitly add $y_2 -z_1 \delta_1 - z_2 \delta_2$. This allows to explicilty account for the measurement errors of the first stage.</span>
<span id="cb42-144"><a href="#cb42-144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-145"><a href="#cb42-145" aria-hidden="true" tabindex="-1"></a>There is a third option, which I will call **two-step-mle**. I call it this way, because the ivprobit will be estimated using @eq-q1 and @eq-q6. However, I call it MLE, because both equations are estimated simultaneously using MLE:</span>
<span id="cb42-146"><a href="#cb42-146" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-147"><a href="#cb42-147" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-148"><a href="#cb42-148" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb42-149"><a href="#cb42-149" aria-hidden="true" tabindex="-1"></a>L_i &amp;= L_i^1*L_i^2 <span class="sc">\\</span></span>
<span id="cb42-150"><a href="#cb42-150" aria-hidden="true" tabindex="-1"></a>L_i^1 &amp;= \phi(y_2,z_1\delta_1 + z_2 \delta_2, \sigma_2) <span class="sc">\\</span></span>
<span id="cb42-151"><a href="#cb42-151" aria-hidden="true" tabindex="-1"></a>\hat P(y_1|.) &amp;=  \Phi \left(  z_1 \beta^r_1 + y_2 \beta^r_2 + \theta \frac {y_2 -z_1 \delta_1 - z_2 \delta_2}{\sigma_2} \right) <span class="sc">\\</span></span>
<span id="cb42-152"><a href="#cb42-152" aria-hidden="true" tabindex="-1"></a>L^2_i &amp; = P(y_1|.)^{y_1} * (1-P(y_1|.))^{1-y_1}</span>
<span id="cb42-153"><a href="#cb42-153" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb42-154"><a href="#cb42-154" aria-hidden="true" tabindex="-1"></a>$${#eq-q8}</span>
<span id="cb42-155"><a href="#cb42-155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-156"><a href="#cb42-156" aria-hidden="true" tabindex="-1"></a>The difference with the standard FIML, is that only rescaled coefficients are estimated, and that the link between both equation is $\theta$ not $\rho$. </span>
<span id="cb42-157"><a href="#cb42-157" aria-hidden="true" tabindex="-1"></a>Nevertheless, For this simplified example, both equations identify exactly the same model. If you are interested in this type of use of -ml- see my paper @rios-avila_standard-error_2018.</span>
<span id="cb42-158"><a href="#cb42-158" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-159"><a href="#cb42-159" aria-hidden="true" tabindex="-1"></a>Compared to the usual two-step approach, however, because the model is estimated simultaneously, the standard errors of all coefficients are correctly estimated, without further calculations (no delta method nor bootstrap).</span>
<span id="cb42-160"><a href="#cb42-160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-161"><a href="#cb42-161" aria-hidden="true" tabindex="-1"></a>One last thing to notice in this model. First, there is a close relationship between $\theta$ and $\rho$, which will affect the rescaled parameters:</span>
<span id="cb42-162"><a href="#cb42-162" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-163"><a href="#cb42-163" aria-hidden="true" tabindex="-1"></a>\theta = \frac{\rho}{\sqrt{1-\rho^2}} \rightarrow \rho =  \frac{\theta}{\sqrt{1+\theta^2}}</span>
<span id="cb42-164"><a href="#cb42-164" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-165"><a href="#cb42-165" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-166"><a href="#cb42-166" aria-hidden="true" tabindex="-1"></a>\beta = \beta^r \times \sqrt{1-\rho^2} = \frac{\beta^r}{\sqrt{1+\theta^2}}</span>
<span id="cb42-167"><a href="#cb42-167" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-168"><a href="#cb42-168" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb42-169"><a href="#cb42-169" aria-hidden="true" tabindex="-1"></a><span class="fu">## The Log Likelihood function</span></span>
<span id="cb42-170"><a href="#cb42-170" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-171"><a href="#cb42-171" aria-hidden="true" tabindex="-1"></a>While I have shown that using FIML and two-step-ml will provide the same results, I'll stick with the two-step approach, as it allows me to derive marginal effects telling the story of what happened to -margins- through different Stata versions.</span>
<span id="cb42-172"><a href="#cb42-172" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-173"><a href="#cb42-173" aria-hidden="true" tabindex="-1"></a>The following program defines this the log-likelihood function for the IV probit, using the two-step approach (@eq-q8), using the following walk-through for the specification:</span>
<span id="cb42-174"><a href="#cb42-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-175"><a href="#cb42-175" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`xb`</span> will contain all the exogenous variables $z_1$ plus the endogenous variable $y_2$</span>
<span id="cb42-176"><a href="#cb42-176" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span><span class="in">`zb`</span> will contain all the exogenous variables $z_1$ and the instruments $z_2$</span>
<span id="cb42-177"><a href="#cb42-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-180"><a href="#cb42-180" aria-hidden="true" tabindex="-1"></a><span class="in">```{stata}</span></span>
<span id="cb42-181"><a href="#cb42-181" aria-hidden="true" tabindex="-1"></a><span class="in">program myivprobit_2sls</span></span>
<span id="cb42-182"><a href="#cb42-182" aria-hidden="true" tabindex="-1"></a><span class="in">    args lnf xb theta zb lnsigma</span></span>
<span id="cb42-183"><a href="#cb42-183" aria-hidden="true" tabindex="-1"></a><span class="in">    qui {</span></span>
<span id="cb42-184"><a href="#cb42-184" aria-hidden="true" tabindex="-1"></a><span class="in">        local y1 $ML_y1</span></span>
<span id="cb42-185"><a href="#cb42-185" aria-hidden="true" tabindex="-1"></a><span class="in">        local y2 $ML_y2</span></span>
<span id="cb42-186"><a href="#cb42-186" aria-hidden="true" tabindex="-1"></a><span class="in">        local u2 (`y2'-`zb')</span></span>
<span id="cb42-187"><a href="#cb42-187" aria-hidden="true" tabindex="-1"></a><span class="in">        tempvar xb_zb p1 p0</span></span>
<span id="cb42-188"><a href="#cb42-188" aria-hidden="true" tabindex="-1"></a><span class="in">        gen double `xb_zb'= `xb'+`theta'*((`u2')/exp(`lnsigma')) </span></span>
<span id="cb42-189"><a href="#cb42-189" aria-hidden="true" tabindex="-1"></a><span class="in">        gen double `p1'   = normal( `xb_zb')</span></span>
<span id="cb42-190"><a href="#cb42-190" aria-hidden="true" tabindex="-1"></a><span class="in">        gen double `p0'   = normal(-`xb_zb')</span></span>
<span id="cb42-191"><a href="#cb42-191" aria-hidden="true" tabindex="-1"></a><span class="in">        tempvar lnf1 lnf2</span></span>
<span id="cb42-192"><a href="#cb42-192" aria-hidden="true" tabindex="-1"></a><span class="in">        gen double `lnf1'  = log(normalden(`y2', `zb', exp(`lnsigma')))</span></span>
<span id="cb42-193"><a href="#cb42-193" aria-hidden="true" tabindex="-1"></a><span class="in">        gen double `lnf2' = log(`p1') if `y1'==1</span></span>
<span id="cb42-194"><a href="#cb42-194" aria-hidden="true" tabindex="-1"></a><span class="in">        replace    `lnf2' = log(`p0') if `y1'==0</span></span>
<span id="cb42-195"><a href="#cb42-195" aria-hidden="true" tabindex="-1"></a><span class="in">        replace `lnf' = `lnf1' + `lnf2'</span></span>
<span id="cb42-196"><a href="#cb42-196" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb42-197"><a href="#cb42-197" aria-hidden="true" tabindex="-1"></a><span class="in">end    </span></span>
<span id="cb42-198"><a href="#cb42-198" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-199"><a href="#cb42-199" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-200"><a href="#cb42-200" aria-hidden="true" tabindex="-1"></a><span class="fu">## The predict program</span></span>
<span id="cb42-201"><a href="#cb42-201" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-202"><a href="#cb42-202" aria-hidden="true" tabindex="-1"></a>So finally, the part that will be a bit more controversial. The prediction of the probability of success!.</span>
<span id="cb42-203"><a href="#cb42-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-204"><a href="#cb42-204" aria-hidden="true" tabindex="-1"></a>The reason why this is controversial is because there are two candidates to identify this expression.</span>
<span id="cb42-205"><a href="#cb42-205" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-206"><a href="#cb42-206" aria-hidden="true" tabindex="-1"></a>The first candidate relates to the structural @eq-q2. Basically, if we can estimate the unscaled coefficients, the predicted outcome could be identified by:</span>
<span id="cb42-207"><a href="#cb42-207" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-208"><a href="#cb42-208" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-209"><a href="#cb42-209" aria-hidden="true" tabindex="-1"></a>P(y_1=1| z_1 , y_2) = \Phi \left( z_1 \beta_1 + y_2 \beta_2  \right) </span>
<span id="cb42-210"><a href="#cb42-210" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-211"><a href="#cb42-211" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-212"><a href="#cb42-212" aria-hidden="true" tabindex="-1"></a>or if one prefers the version based on rescaled coefficients:</span>
<span id="cb42-213"><a href="#cb42-213" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-214"><a href="#cb42-214" aria-hidden="true" tabindex="-1"></a>P(y_1=1| z_1 , y_2) = \Phi \left( z_1 \beta^r_1 * {\sqrt{1-\rho^2}} + y_2 \beta^r_2 * {\sqrt{1-\rho^2}} \right) </span>
<span id="cb42-215"><a href="#cb42-215" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-216"><a href="#cb42-216" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-217"><a href="#cb42-217" aria-hidden="true" tabindex="-1"></a>Thus, marginal effects can be obtained by analyzing either one of these equations alone. Standard errors for this expression can be identified directly only if we estimate the structural equation using FIML, or using the rescaled coefficients, making sure standard errors are calculated acounting for the estimation errors of the first stage.</span>
<span id="cb42-218"><a href="#cb42-218" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-219"><a href="#cb42-219" aria-hidden="true" tabindex="-1"></a>The second option relates to estimate the marginal effects using @eq-q6:</span>
<span id="cb42-220"><a href="#cb42-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-221"><a href="#cb42-221" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-222"><a href="#cb42-222" aria-hidden="true" tabindex="-1"></a> P(y_1=1| z_1 , y_2, \hat{u}_2 ) = \Phi \left( z_1 \beta^r_1 + y_2 \beta^r_2 + \theta \hat{u}_2 \right) </span>
<span id="cb42-223"><a href="#cb42-223" aria-hidden="true" tabindex="-1"></a>$${#eq-q6a}</span>
<span id="cb42-224"><a href="#cb42-224" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-225"><a href="#cb42-225" aria-hidden="true" tabindex="-1"></a>However, because $hat u_2$ is never observed, it is usually recommended to average (but not ignore) the impact of $\hat u_2$ on the equation:</span>
<span id="cb42-226"><a href="#cb42-226" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-227"><a href="#cb42-227" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-228"><a href="#cb42-228" aria-hidden="true" tabindex="-1"></a>P(y_1=1| z_1 , y_2) = E \left( \Phi \left( z_1 \beta^r_1 + y_2 \beta^r_2 + \theta \hat{u}_2 \right)| z_1, y_2 \right) </span>
<span id="cb42-229"><a href="#cb42-229" aria-hidden="true" tabindex="-1"></a>$${#eq-q6b}</span>
<span id="cb42-230"><a href="#cb42-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-231"><a href="#cb42-231" aria-hidden="true" tabindex="-1"></a>The bottom line: If one uses the two-step approach, marginal effects could be estimated assuming $\hat u_2$ is just another exogenous variable in the model. The difficulty would be obtaining the correct estimation of standard errors. </span>
<span id="cb42-232"><a href="#cb42-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-233"><a href="#cb42-233" aria-hidden="true" tabindex="-1"></a>So lets write these two options into a "predict" program.</span>
<span id="cb42-234"><a href="#cb42-234" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-237"><a href="#cb42-237" aria-hidden="true" tabindex="-1"></a><span class="in">```{stata}</span></span>
<span id="cb42-238"><a href="#cb42-238" aria-hidden="true" tabindex="-1"></a><span class="in">program myivprobit_p</span></span>
<span id="cb42-239"><a href="#cb42-239" aria-hidden="true" tabindex="-1"></a><span class="in">    syntax newvarname [if] [in] , [ pr1 pr2  *]</span></span>
<span id="cb42-240"><a href="#cb42-240" aria-hidden="true" tabindex="-1"></a><span class="in">    if "`pr1'`pr2'" =="" {</span></span>
<span id="cb42-241"><a href="#cb42-241" aria-hidden="true" tabindex="-1"></a><span class="in">        ml_p `0'</span></span>
<span id="cb42-242"><a href="#cb42-242" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb42-243"><a href="#cb42-243" aria-hidden="true" tabindex="-1"></a><span class="in">    tokenize `e(depvar)'</span></span>
<span id="cb42-244"><a href="#cb42-244" aria-hidden="true" tabindex="-1"></a><span class="in">    local y1  `1'</span></span>
<span id="cb42-245"><a href="#cb42-245" aria-hidden="true" tabindex="-1"></a><span class="in">    local y2  `2'</span></span>
<span id="cb42-246"><a href="#cb42-246" aria-hidden="true" tabindex="-1"></a><span class="in">    marksample touse, novarlist</span></span>
<span id="cb42-247"><a href="#cb42-247" aria-hidden="true" tabindex="-1"></a><span class="in">    if "`pr1'" !=""  {</span></span>
<span id="cb42-248"><a href="#cb42-248" aria-hidden="true" tabindex="-1"></a><span class="in">        tempvar xb zb theta lnsigma</span></span>
<span id="cb42-249"><a href="#cb42-249" aria-hidden="true" tabindex="-1"></a><span class="in">        _predict double `xb'   , eq(#1)</span></span>
<span id="cb42-250"><a href="#cb42-250" aria-hidden="true" tabindex="-1"></a><span class="in">        _predict double `theta', eq(#2)</span></span>
<span id="cb42-251"><a href="#cb42-251" aria-hidden="true" tabindex="-1"></a><span class="in">        _predict double `zb'   , eq(#3) </span></span>
<span id="cb42-252"><a href="#cb42-252" aria-hidden="true" tabindex="-1"></a><span class="in">        _predict double `lnsigma', eq(#4)       </span></span>
<span id="cb42-253"><a href="#cb42-253" aria-hidden="true" tabindex="-1"></a><span class="in">        gen `typlist' `varlist' = ///</span></span>
<span id="cb42-254"><a href="#cb42-254" aria-hidden="true" tabindex="-1"></a><span class="in">            normal(`xb'+`theta'*(`y2'-`zb')/exp(`lnsigma')) if `touse'</span></span>
<span id="cb42-255"><a href="#cb42-255" aria-hidden="true" tabindex="-1"></a><span class="in">        label var `varlist' "P(y=1|X) two-step"</span></span>
<span id="cb42-256"><a href="#cb42-256" aria-hidden="true" tabindex="-1"></a><span class="in">    }       </span></span>
<span id="cb42-257"><a href="#cb42-257" aria-hidden="true" tabindex="-1"></a><span class="in">    else if "`pr2'"!="" {</span></span>
<span id="cb42-258"><a href="#cb42-258" aria-hidden="true" tabindex="-1"></a><span class="in">        tempvar xb zb theta lnsigma</span></span>
<span id="cb42-259"><a href="#cb42-259" aria-hidden="true" tabindex="-1"></a><span class="in">        _predict double `xb' , eq(#1)</span></span>
<span id="cb42-260"><a href="#cb42-260" aria-hidden="true" tabindex="-1"></a><span class="in">        _predict double `theta'  , eq(#2)</span></span>
<span id="cb42-261"><a href="#cb42-261" aria-hidden="true" tabindex="-1"></a><span class="in">        gen `typlist' `varlist' = ///</span></span>
<span id="cb42-262"><a href="#cb42-262" aria-hidden="true" tabindex="-1"></a><span class="in">            normal(`xb'/sqrt(1+`theta'^2)) if `touse'</span></span>
<span id="cb42-263"><a href="#cb42-263" aria-hidden="true" tabindex="-1"></a><span class="in">        label var `varlist' "P(y=1|X) FIML"</span></span>
<span id="cb42-264"><a href="#cb42-264" aria-hidden="true" tabindex="-1"></a><span class="in">    }</span></span>
<span id="cb42-265"><a href="#cb42-265" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb42-266"><a href="#cb42-266" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-267"><a href="#cb42-267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-268"><a href="#cb42-268" aria-hidden="true" tabindex="-1"></a>The first option <span class="in">`pr1`</span> will estimate the predicted probability as if the model were estimated using the two-step approach, whereas the second will estimate the predicted probability based on the structural equation.</span>
<span id="cb42-269"><a href="#cb42-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-270"><a href="#cb42-270" aria-hidden="true" tabindex="-1"></a>Alright, so lets estimate the model and compare the results with the built-in ivprobit command:</span>
<span id="cb42-271"><a href="#cb42-271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-274"><a href="#cb42-274" aria-hidden="true" tabindex="-1"></a><span class="in">```{stata}</span></span>
<span id="cb42-275"><a href="#cb42-275" aria-hidden="true" tabindex="-1"></a><span class="in">clear  </span></span>
<span id="cb42-276"><a href="#cb42-276" aria-hidden="true" tabindex="-1"></a><span class="in">webuse laborsup</span></span>
<span id="cb42-277"><a href="#cb42-277" aria-hidden="true" tabindex="-1"></a><span class="in">global  y1   fem_work</span></span>
<span id="cb42-278"><a href="#cb42-278" aria-hidden="true" tabindex="-1"></a><span class="in">global  z1   fem_educ   kids  </span></span>
<span id="cb42-279"><a href="#cb42-279" aria-hidden="true" tabindex="-1"></a><span class="in">global  y2   other_inc</span></span>
<span id="cb42-280"><a href="#cb42-280" aria-hidden="true" tabindex="-1"></a><span class="in">global  z2   male_educ   </span></span>
<span id="cb42-281"><a href="#cb42-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-282"><a href="#cb42-282" aria-hidden="true" tabindex="-1"></a><span class="in">*Built in command:</span></span>
<span id="cb42-283"><a href="#cb42-283" aria-hidden="true" tabindex="-1"></a><span class="in">ivprobit $y1  $z1 ($y2 = $z2), two</span></span>
<span id="cb42-284"><a href="#cb42-284" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-285"><a href="#cb42-285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-288"><a href="#cb42-288" aria-hidden="true" tabindex="-1"></a><span class="in">```{stata}</span></span>
<span id="cb42-289"><a href="#cb42-289" aria-hidden="true" tabindex="-1"></a><span class="in">*my ivprobit two-step</span></span>
<span id="cb42-290"><a href="#cb42-290" aria-hidden="true" tabindex="-1"></a><span class="in">ml model lf myivprobit_2sls ($y1 = $z1  $y2 ) ///</span></span>
<span id="cb42-291"><a href="#cb42-291" aria-hidden="true" tabindex="-1"></a><span class="in">         (theta:) ($y2 = $z1 $z2  ) (lnsigma:) , ///</span></span>
<span id="cb42-292"><a href="#cb42-292" aria-hidden="true" tabindex="-1"></a><span class="in">         technique(nr bhhh) init(lnsigma:_cons = 2.81 ) maximize nolog</span></span>
<span id="cb42-293"><a href="#cb42-293" aria-hidden="true" tabindex="-1"></a><span class="in">ml display</span></span>
<span id="cb42-294"><a href="#cb42-294" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-295"><a href="#cb42-295" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-296"><a href="#cb42-296" aria-hidden="true" tabindex="-1"></a>You can see right away that except for differences attributed to rounding errors and degrees of freedom, the results are virtually the same.</span>
<span id="cb42-297"><a href="#cb42-297" aria-hidden="true" tabindex="-1"></a>It is also reasuring to see that the results are also the same when we compared ivprobit-mle and the rescaled coefficients:</span>
<span id="cb42-298"><a href="#cb42-298" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-301"><a href="#cb42-301" aria-hidden="true" tabindex="-1"></a><span class="in">```{stata}</span></span>
<span id="cb42-302"><a href="#cb42-302" aria-hidden="true" tabindex="-1"></a><span class="in">*FIML</span></span>
<span id="cb42-303"><a href="#cb42-303" aria-hidden="true" tabindex="-1"></a><span class="in">ivprobit $y1  $z1 ($y2 = $z2), ml nolog</span></span>
<span id="cb42-304"><a href="#cb42-304" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-305"><a href="#cb42-305" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-308"><a href="#cb42-308" aria-hidden="true" tabindex="-1"></a><span class="in">```{stata}</span></span>
<span id="cb42-309"><a href="#cb42-309" aria-hidden="true" tabindex="-1"></a><span class="in">*my ivprobit two-step</span></span>
<span id="cb42-310"><a href="#cb42-310" aria-hidden="true" tabindex="-1"></a><span class="in">ml model lf myivprobit_2sls ($y1 = $z1  $y2 )  (theta:) ($y2 = $z1 $z2  ) (lnsigma:) , ///</span></span>
<span id="cb42-311"><a href="#cb42-311" aria-hidden="true" tabindex="-1"></a><span class="in">    technique(nr bhhh)   init(lnsigma:_cons = 2.81 ) maximize nolog</span></span>
<span id="cb42-312"><a href="#cb42-312" aria-hidden="true" tabindex="-1"></a><span class="in">adde local predict myivprobit_p                 </span></span>
<span id="cb42-313"><a href="#cb42-313" aria-hidden="true" tabindex="-1"></a><span class="in">est store myivp</span></span>
<span id="cb42-314"><a href="#cb42-314" aria-hidden="true" tabindex="-1"></a><span class="in">*with rescaled coefficients:</span></span>
<span id="cb42-315"><a href="#cb42-315" aria-hidden="true" tabindex="-1"></a><span class="in">nlcom   (other_inc: _b[other_inc]/sqrt(1+_b[theta:_cons]^2)) ///</span></span>
<span id="cb42-316"><a href="#cb42-316" aria-hidden="true" tabindex="-1"></a><span class="in">        (fem_educ: _b[fem_educ]/sqrt(1+_b[theta:_cons]^2)) ///</span></span>
<span id="cb42-317"><a href="#cb42-317" aria-hidden="true" tabindex="-1"></a><span class="in">        (kids: _b[kids]/sqrt(1+_b[theta:_cons]^2)) ///</span></span>
<span id="cb42-318"><a href="#cb42-318" aria-hidden="true" tabindex="-1"></a><span class="in">        (cons: _b[_cons]/sqrt(1+_b[theta:_cons]^2)) </span></span>
<span id="cb42-319"><a href="#cb42-319" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-320"><a href="#cb42-320" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-321"><a href="#cb42-321" aria-hidden="true" tabindex="-1"></a>Again, showing exactly the same results</span>
<span id="cb42-322"><a href="#cb42-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-323"><a href="#cb42-323" aria-hidden="true" tabindex="-1"></a><span class="fu">## A Story of marginal effects</span></span>
<span id="cb42-324"><a href="#cb42-324" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-325"><a href="#cb42-325" aria-hidden="true" tabindex="-1"></a>Let me now walk you through the Story of marginal effects with ivprobit.</span>
<span id="cb42-326"><a href="#cb42-326" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-327"><a href="#cb42-327" aria-hidden="true" tabindex="-1"></a><span class="fu">### Stata 13</span></span>
<span id="cb42-328"><a href="#cb42-328" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-329"><a href="#cb42-329" aria-hidden="true" tabindex="-1"></a>Back in Stata 13, marginal effects for IV probit were estimated using the structural equation coeffients:</span>
<span id="cb42-330"><a href="#cb42-330" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-331"><a href="#cb42-331" aria-hidden="true" tabindex="-1"></a>P(y_1=1|z_1,y_2)=\Phi(z_1\beta_1+y_2\beta_2)</span>
<span id="cb42-332"><a href="#cb42-332" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-333"><a href="#cb42-333" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-334"><a href="#cb42-334" aria-hidden="true" tabindex="-1"></a>So that marginal effects were defined as:</span>
<span id="cb42-335"><a href="#cb42-335" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-336"><a href="#cb42-336" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb42-337"><a href="#cb42-337" aria-hidden="true" tabindex="-1"></a>\frac{\partial P(y_1=1|.)}{\partial z_1} = \phi ( z_1 \beta_1 + y_2 \beta_2  ) \beta_1 <span class="sc">\\</span></span>
<span id="cb42-338"><a href="#cb42-338" aria-hidden="true" tabindex="-1"></a>\frac{\partial P(y_1=1|.)}{\partial y_2} = \phi ( z_1 \beta_1 + y_2 \beta_2  ) \beta_2 </span>
<span id="cb42-339"><a href="#cb42-339" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb42-340"><a href="#cb42-340" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-341"><a href="#cb42-341" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb42-342"><a href="#cb42-342" aria-hidden="true" tabindex="-1"></a>:::{.callout-note}</span>
<span id="cb42-343"><a href="#cb42-343" aria-hidden="true" tabindex="-1"></a>As you may have noticed, I'm rewritting few of my older posts using Quarto. So, I can only use Stata17 dynamically.</span>
<span id="cb42-344"><a href="#cb42-344" aria-hidden="true" tabindex="-1"></a>Because of that the code you will see below will not be reproducible, unless you have the same Stata version</span>
<span id="cb42-345"><a href="#cb42-345" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb42-346"><a href="#cb42-346" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-347"><a href="#cb42-347" aria-hidden="true" tabindex="-1"></a>If you have access to Stata 13, you will be able to reproduce the following output:</span>
<span id="cb42-348"><a href="#cb42-348" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-349"><a href="#cb42-349" aria-hidden="true" tabindex="-1"></a><span class="in">```stata</span></span>
<span id="cb42-350"><a href="#cb42-350" aria-hidden="true" tabindex="-1"></a><span class="in">margins, dydx(*) predict(pr)</span></span>
<span id="cb42-351"><a href="#cb42-351" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-352"><a href="#cb42-352" aria-hidden="true" tabindex="-1"></a><span class="in">Average marginal effects                          Number of obs   =        500</span></span>
<span id="cb42-353"><a href="#cb42-353" aria-hidden="true" tabindex="-1"></a><span class="in">Model VCE    : OIM</span></span>
<span id="cb42-354"><a href="#cb42-354" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-355"><a href="#cb42-355" aria-hidden="true" tabindex="-1"></a><span class="in">Expression   : Probability of positive outcome, predict(pr)</span></span>
<span id="cb42-356"><a href="#cb42-356" aria-hidden="true" tabindex="-1"></a><span class="in">dy/dx w.r.t. : other_inc fem_educ kids male_educ</span></span>
<span id="cb42-357"><a href="#cb42-357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-358"><a href="#cb42-358" aria-hidden="true" tabindex="-1"></a><span class="in">------------------------------------------------------------------------------</span></span>
<span id="cb42-359"><a href="#cb42-359" aria-hidden="true" tabindex="-1"></a><span class="in">             |            Delta-method</span></span>
<span id="cb42-360"><a href="#cb42-360" aria-hidden="true" tabindex="-1"></a><span class="in">             |      dy/dx   Std. Err.      z    P&gt;|z|     [95% Conf. Interval]</span></span>
<span id="cb42-361"><a href="#cb42-361" aria-hidden="true" tabindex="-1"></a><span class="in">-------------+----------------------------------------------------------------</span></span>
<span id="cb42-362"><a href="#cb42-362" aria-hidden="true" tabindex="-1"></a><span class="in">   other_inc |   -.014015   .0009836   -14.25   0.000    -.0159428   -.0120872</span></span>
<span id="cb42-363"><a href="#cb42-363" aria-hidden="true" tabindex="-1"></a><span class="in">    fem_educ |   .0545129   .0066007     8.26   0.000     .0415758      .06745</span></span>
<span id="cb42-364"><a href="#cb42-364" aria-hidden="true" tabindex="-1"></a><span class="in">        kids |  -.0470199   .0123397    -3.81   0.000    -.0712052   -.0228346</span></span>
<span id="cb42-365"><a href="#cb42-365" aria-hidden="true" tabindex="-1"></a><span class="in">   male_educ |          0  (omitted)</span></span>
<span id="cb42-366"><a href="#cb42-366" aria-hidden="true" tabindex="-1"></a><span class="in">------------------------------------------------------------------------------</span></span>
<span id="cb42-367"><a href="#cb42-367" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-368"><a href="#cb42-368" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-369"><a href="#cb42-369" aria-hidden="true" tabindex="-1"></a>This marginal effects are emulated using pr2 after myivprobit:</span>
<span id="cb42-370"><a href="#cb42-370" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-373"><a href="#cb42-373" aria-hidden="true" tabindex="-1"></a><span class="in">```{stata}</span></span>
<span id="cb42-374"><a href="#cb42-374" aria-hidden="true" tabindex="-1"></a><span class="in">est restore myivp</span></span>
<span id="cb42-375"><a href="#cb42-375" aria-hidden="true" tabindex="-1"></a><span class="in">margins, dydx(*) predict(pr2) force</span></span>
<span id="cb42-376"><a href="#cb42-376" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-377"><a href="#cb42-377" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-378"><a href="#cb42-378" aria-hidden="true" tabindex="-1"></a>You will see output from margins also include <span class="in">`male_educ`</span> in the list of exogenous variables. This happens because it is an explanatory variable for at least one equation in the model (first). However, because this variable is not included in the second equation, it has a no effect on it.</span>
<span id="cb42-379"><a href="#cb42-379" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-380"><a href="#cb42-380" aria-hidden="true" tabindex="-1"></a><span class="fu">## Stata 14.1</span></span>
<span id="cb42-381"><a href="#cb42-381" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-382"><a href="#cb42-382" aria-hidden="true" tabindex="-1"></a>When we reached Stata 14.1, a change was introduced in how probabilities were calculated after ivprobit. As it says in the "whatsnew" material, the new formulation would take into account endogeneity.</span>
<span id="cb42-383"><a href="#cb42-383" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-384"><a href="#cb42-384" aria-hidden="true" tabindex="-1"></a>Specifically, they use what I call the 2sls predicted probabilities, following equation (5) wth the caveat that $\hat u_2$ was substituted by $y_2 - z_1 \delta_1 -z2\delta_2$:</span>
<span id="cb42-385"><a href="#cb42-385" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb42-386"><a href="#cb42-386" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-387"><a href="#cb42-387" aria-hidden="true" tabindex="-1"></a>P(y_1=1|z_1,y_2,z_2) =\Phi \left( </span>
<span id="cb42-388"><a href="#cb42-388" aria-hidden="true" tabindex="-1"></a>    \frac{z_1 \beta_1 + y_2 \beta_2 + \rho \frac{y_2 - z_1 \delta_1 - z_2 \delta_2}{\sigma_2}}</span>
<span id="cb42-389"><a href="#cb42-389" aria-hidden="true" tabindex="-1"></a>    {\sqrt{1-\rho^2}}   \right)</span>
<span id="cb42-390"><a href="#cb42-390" aria-hidden="true" tabindex="-1"></a>$${#eq-q12}</span>
<span id="cb42-391"><a href="#cb42-391" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-392"><a href="#cb42-392" aria-hidden="true" tabindex="-1"></a>While the two equations above are basically the same, they have important differences when marginal effects are estimated by software. Specifically, the probability of sucess is now a function of $z_2$!.</span>
<span id="cb42-393"><a href="#cb42-393" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-394"><a href="#cb42-394" aria-hidden="true" tabindex="-1"></a>So let me explain first what Stata 14.1, did. To estimate marginal effects, partial derivatives were based on @eq-q12:</span>
<span id="cb42-395"><a href="#cb42-395" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb42-396"><a href="#cb42-396" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-397"><a href="#cb42-397" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb42-398"><a href="#cb42-398" aria-hidden="true" tabindex="-1"></a> \frac{\partial P(y=1|.)}{\partial z_1} &amp;= </span>
<span id="cb42-399"><a href="#cb42-399" aria-hidden="true" tabindex="-1"></a>  \phi(.)*\left( \frac{\beta_1}{\sqrt{1-\rho^2}}  </span>
<span id="cb42-400"><a href="#cb42-400" aria-hidden="true" tabindex="-1"></a>  -\frac{\rho}{\sqrt{1-\rho^2}} * \frac{\delta_1}{\sigma_2} \right)  <span class="sc">\\</span></span>
<span id="cb42-401"><a href="#cb42-401" aria-hidden="true" tabindex="-1"></a>   \frac{\partial P(y=1|.)}{\partial z_2} &amp;=</span>
<span id="cb42-402"><a href="#cb42-402" aria-hidden="true" tabindex="-1"></a>    \phi(.)*\left( 0</span>
<span id="cb42-403"><a href="#cb42-403" aria-hidden="true" tabindex="-1"></a>  -\frac{\rho}{\sqrt{1-\rho^2}} * \frac{\delta_2}{\sigma_2} \right)  <span class="sc">\\</span></span>
<span id="cb42-404"><a href="#cb42-404" aria-hidden="true" tabindex="-1"></a> \frac{\partial P(y=1|.)}{\partial y_2} &amp;=</span>
<span id="cb42-405"><a href="#cb42-405" aria-hidden="true" tabindex="-1"></a>    \phi(.)*\left( \frac{\beta_2}{\sqrt{1-\rho^2}}  </span>
<span id="cb42-406"><a href="#cb42-406" aria-hidden="true" tabindex="-1"></a>    +\frac{1}{\sqrt{1-\rho^2}} * \frac{1}{\sigma_2} \right)    </span>
<span id="cb42-407"><a href="#cb42-407" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb42-408"><a href="#cb42-408" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb42-409"><a href="#cb42-409" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb42-410"><a href="#cb42-410" aria-hidden="true" tabindex="-1"></a>From the technical point of view, these partial derivatives are correct, since they are capturing both the direct and indirect effects of all variables on the probability of success. Something similar to total, rather than partial, derivative. </span>
<span id="cb42-411"><a href="#cb42-411" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb42-412"><a href="#cb42-412" aria-hidden="true" tabindex="-1"></a>The problem, however, is that this assumes we could actually observe how the unobserved component changes when other variables change. Standard regression analysis, however, would say that these unobserved components should be considered as fixed, and instead one should estimate marginal effects averaging over the unobserved factors. Thus, the second term on each one of the above derivatives should be zero.</span>
<span id="cb42-413"><a href="#cb42-413" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-414"><a href="#cb42-414" aria-hidden="true" tabindex="-1"></a>Nevertheless, if you try estimating marginal effects with Stata 14.2, you will get the following result:</span>
<span id="cb42-415"><a href="#cb42-415" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-416"><a href="#cb42-416" aria-hidden="true" tabindex="-1"></a><span class="in">```stata</span></span>
<span id="cb42-417"><a href="#cb42-417" aria-hidden="true" tabindex="-1"></a><span class="in">margins, dydx(*) predict(pr)</span></span>
<span id="cb42-418"><a href="#cb42-418" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-419"><a href="#cb42-419" aria-hidden="true" tabindex="-1"></a><span class="in">Average marginal effects                        Number of obs     =        500</span></span>
<span id="cb42-420"><a href="#cb42-420" aria-hidden="true" tabindex="-1"></a><span class="in">Model VCE    : OIM</span></span>
<span id="cb42-421"><a href="#cb42-421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-422"><a href="#cb42-422" aria-hidden="true" tabindex="-1"></a><span class="in">Expression   : Probability of positive outcome, predict(pr)</span></span>
<span id="cb42-423"><a href="#cb42-423" aria-hidden="true" tabindex="-1"></a><span class="in">dy/dx w.r.t. : other_inc fem_educ kids male_educ</span></span>
<span id="cb42-424"><a href="#cb42-424" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-425"><a href="#cb42-425" aria-hidden="true" tabindex="-1"></a><span class="in">------------------------------------------------------------------------------</span></span>
<span id="cb42-426"><a href="#cb42-426" aria-hidden="true" tabindex="-1"></a><span class="in">             |            Delta-method</span></span>
<span id="cb42-427"><a href="#cb42-427" aria-hidden="true" tabindex="-1"></a><span class="in">             |      dy/dx   Std. Err.      z    P&gt;|z|     [95% Conf. Interval]</span></span>
<span id="cb42-428"><a href="#cb42-428" aria-hidden="true" tabindex="-1"></a><span class="in">-------------+----------------------------------------------------------------</span></span>
<span id="cb42-429"><a href="#cb42-429" aria-hidden="true" tabindex="-1"></a><span class="in">   other_inc |  -.0097802   .0014994    -6.52   0.000     -.012719   -.0068414</span></span>
<span id="cb42-430"><a href="#cb42-430" aria-hidden="true" tabindex="-1"></a><span class="in">    fem_educ |   .0623273    .007099     8.78   0.000     .0484135     .076241</span></span>
<span id="cb42-431"><a href="#cb42-431" aria-hidden="true" tabindex="-1"></a><span class="in">        kids |  -.0614265   .0139446    -4.41   0.000    -.0887574   -.0340956</span></span>
<span id="cb42-432"><a href="#cb42-432" aria-hidden="true" tabindex="-1"></a><span class="in">   male_educ |  -.0194406   .0022103    -8.80   0.000    -.0237728   -.0151084</span></span>
<span id="cb42-433"><a href="#cb42-433" aria-hidden="true" tabindex="-1"></a><span class="in">------------------------------------------------------------------------------</span></span>
<span id="cb42-434"><a href="#cb42-434" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-435"><a href="#cb42-435" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-436"><a href="#cb42-436" aria-hidden="true" tabindex="-1"></a>To replicate this using <span class="in">`myivprobit`</span>, I would estimate marginal effects using option <span class="in">`pr1`</span>, requesting derivates to be estimated without the **chain rule** (<span class="in">`nochain`</span>). This makes sure that one takes into account the effect of all changes in $y_2, z_1$ and $z_2$ on the predicted outcome $P(y=1|.)$:  </span>
<span id="cb42-437"><a href="#cb42-437" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-440"><a href="#cb42-440" aria-hidden="true" tabindex="-1"></a><span class="in">```{stata}</span></span>
<span id="cb42-441"><a href="#cb42-441" aria-hidden="true" tabindex="-1"></a><span class="in">est restore myivp</span></span>
<span id="cb42-442"><a href="#cb42-442" aria-hidden="true" tabindex="-1"></a><span class="in">margins, dydx(*) predict(pr1) force nochain</span></span>
<span id="cb42-443"><a href="#cb42-443" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-444"><a href="#cb42-444" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-445"><a href="#cb42-445" aria-hidden="true" tabindex="-1"></a><span class="fu">## Stata 16</span></span>
<span id="cb42-446"><a href="#cb42-446" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-447"><a href="#cb42-447" aria-hidden="true" tabindex="-1"></a>The earlier version of Stata 16 came with very similar problems as the ones mentioned above. However, due in part to an earlier version of this article, in November of 2020, Stata made a correction in how marginal effects were estimated for <span class="in">`ivprobit`</span> as well as other related commands (see update 19nov2020).</span>
<span id="cb42-448"><a href="#cb42-448" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-449"><a href="#cb42-449" aria-hidden="true" tabindex="-1"></a>In this update, they change the default option and now produces the correct marginal effects, assuming the predicted errors are fixed. </span>
<span id="cb42-450"><a href="#cb42-450" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-451"><a href="#cb42-451" aria-hidden="true" tabindex="-1"></a>Let's take a closer look at the findings. First, it appears that Stata 14, 15, and early 16 versions were unintentionally estimating a partial effect that accounted for a second-order effect through the first stage regression. While this might have a negligible effect on the exogenous variables, it could have a considerable impact on the endogenous variable of interest, resulting in some people reporting negative marginal effects even when the estimated coefficient was positive. Additionally, the instrument, in this case <span class="in">`male_educ`</span>, would also appear in the output, capturing only a second-order effect on the outcome of interest.</span>
<span id="cb42-452"><a href="#cb42-452" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-453"><a href="#cb42-453" aria-hidden="true" tabindex="-1"></a>However, after a lively discussion on Statalist, including input from Prof. Wooldridge, it was revealed that Stata (and margins) was incorrectly estimating marginal effects. As shown here, partial derivatives were being estimated through the first and second equations, leading to incorrect results.</span>
<span id="cb42-454"><a href="#cb42-454" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-455"><a href="#cb42-455" aria-hidden="true" tabindex="-1"></a>Prof. Wooldridge recommended a manual two-step approach for estimating marginal effects, with standard errors obtained via bootstrap, using @eq-q6a to estimate the partial effects. This makes a difference because we will be making the explicit assumption that </span>
<span id="cb42-456"><a href="#cb42-456" aria-hidden="true" tabindex="-1"></a>$\hat u_2$ does not change when the other variables change. This will modify the partial effects to the following:</span>
<span id="cb42-457"><a href="#cb42-457" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-458"><a href="#cb42-458" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-459"><a href="#cb42-459" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb42-460"><a href="#cb42-460" aria-hidden="true" tabindex="-1"></a> \frac{\partial P(y=1|.)}{\partial z_1} &amp;= </span>
<span id="cb42-461"><a href="#cb42-461" aria-hidden="true" tabindex="-1"></a>  \phi(.)*\left( \frac{\beta_1}{\sqrt{1-\rho^2}} \right)   <span class="sc">\\</span></span>
<span id="cb42-462"><a href="#cb42-462" aria-hidden="true" tabindex="-1"></a>   \frac{\partial P(y=1|.)}{\partial z_2} &amp;=</span>
<span id="cb42-463"><a href="#cb42-463" aria-hidden="true" tabindex="-1"></a>    \phi(.)* 0  <span class="sc">\\</span></span>
<span id="cb42-464"><a href="#cb42-464" aria-hidden="true" tabindex="-1"></a>  \frac{\partial P(y=1|.)}{\partial y_2} &amp;=</span>
<span id="cb42-465"><a href="#cb42-465" aria-hidden="true" tabindex="-1"></a>    \phi(.)* \left( \frac{\beta_2}{\sqrt{1-\rho^2}}  \right)     </span>
<span id="cb42-466"><a href="#cb42-466" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb42-467"><a href="#cb42-467" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb42-468"><a href="#cb42-468" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb42-469"><a href="#cb42-469" aria-hidden="true" tabindex="-1"></a>The differences with the "structural" marginal effects are that the evaluation of $\phi(.)$ includes the predicted values of the errors ($\hat u_2$), and that coefficients used correspond to the two-step procedure ones (rescaled).</span>
<span id="cb42-470"><a href="#cb42-470" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-471"><a href="#cb42-471" aria-hidden="true" tabindex="-1"></a>To show empirically how this works, we can compare the builtin command, with the "two-step" procedure suggested by Prof. Wooldridge:</span>
<span id="cb42-472"><a href="#cb42-472" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-475"><a href="#cb42-475" aria-hidden="true" tabindex="-1"></a><span class="in">```{stata}</span></span>
<span id="cb42-476"><a href="#cb42-476" aria-hidden="true" tabindex="-1"></a><span class="in">* two step procedure</span></span>
<span id="cb42-477"><a href="#cb42-477" aria-hidden="true" tabindex="-1"></a><span class="in">* 1st</span></span>
<span id="cb42-478"><a href="#cb42-478" aria-hidden="true" tabindex="-1"></a><span class="in">qui: reg $y2 $z1 $z2</span></span>
<span id="cb42-479"><a href="#cb42-479" aria-hidden="true" tabindex="-1"></a><span class="in">predict double u2, resid</span></span>
<span id="cb42-480"><a href="#cb42-480" aria-hidden="true" tabindex="-1"></a><span class="in">* 2nd</span></span>
<span id="cb42-481"><a href="#cb42-481" aria-hidden="true" tabindex="-1"></a><span class="in">qui: probit $y1 $z1 $y2 u2, nolog</span></span>
<span id="cb42-482"><a href="#cb42-482" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-483"><a href="#cb42-483" aria-hidden="true" tabindex="-1"></a><span class="in">margins, dydx(*) predict(pr)</span></span>
<span id="cb42-484"><a href="#cb42-484" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-485"><a href="#cb42-485" aria-hidden="true" tabindex="-1"></a>The standard errors here will not be correct, but bootstrap could be applied to obtain corrected standard errors.</span>
<span id="cb42-486"><a href="#cb42-486" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-487"><a href="#cb42-487" aria-hidden="true" tabindex="-1"></a>With the correction to estimation of marginal effects pushed in Novenber of 2020, we can produce the correct point estimates for marginal effects, which follows Prof Wooldrige suggestion, and my discussion presented here.</span>
<span id="cb42-488"><a href="#cb42-488" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-489"><a href="#cb42-489" aria-hidden="true" tabindex="-1"></a><span class="in">```stata</span></span>
<span id="cb42-490"><a href="#cb42-490" aria-hidden="true" tabindex="-1"></a><span class="in">** built-in command</span></span>
<span id="cb42-491"><a href="#cb42-491" aria-hidden="true" tabindex="-1"></a><span class="in">qui:ivprobit $y1  $z1 ($y2 = $z2), ml</span></span>
<span id="cb42-492"><a href="#cb42-492" aria-hidden="true" tabindex="-1"></a><span class="in">margins, dydx(*) predict(pr)</span></span>
<span id="cb42-493"><a href="#cb42-493" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-494"><a href="#cb42-494" aria-hidden="true" tabindex="-1"></a><span class="in">Average marginal effects                        Number of obs     =        500</span></span>
<span id="cb42-495"><a href="#cb42-495" aria-hidden="true" tabindex="-1"></a><span class="in">Model VCE    : OIM</span></span>
<span id="cb42-496"><a href="#cb42-496" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-497"><a href="#cb42-497" aria-hidden="true" tabindex="-1"></a><span class="in">Expression   : Average structural function probabilities, predict(pr)</span></span>
<span id="cb42-498"><a href="#cb42-498" aria-hidden="true" tabindex="-1"></a><span class="in">dy/dx w.r.t. : other_inc fem_educ kids</span></span>
<span id="cb42-499"><a href="#cb42-499" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-500"><a href="#cb42-500" aria-hidden="true" tabindex="-1"></a><span class="in">------------------------------------------------------------------------------</span></span>
<span id="cb42-501"><a href="#cb42-501" aria-hidden="true" tabindex="-1"></a><span class="in">             |            Delta-method</span></span>
<span id="cb42-502"><a href="#cb42-502" aria-hidden="true" tabindex="-1"></a><span class="in">             |      dy/dx   Std. Err.      z    P&gt;|z|     [95% Conf. Interval]</span></span>
<span id="cb42-503"><a href="#cb42-503" aria-hidden="true" tabindex="-1"></a><span class="in">-------------+----------------------------------------------------------------</span></span>
<span id="cb42-504"><a href="#cb42-504" aria-hidden="true" tabindex="-1"></a><span class="in">   other_inc |  -.0166128   .0012889   -12.89   0.000     -.019139   -.0140867</span></span>
<span id="cb42-505"><a href="#cb42-505" aria-hidden="true" tabindex="-1"></a><span class="in">    fem_educ |   .0646175   .0073529     8.79   0.000      .050206     .079029</span></span>
<span id="cb42-506"><a href="#cb42-506" aria-hidden="true" tabindex="-1"></a><span class="in">        kids |  -.0557355   .0144233    -3.86   0.000    -.0840047   -.0274664</span></span>
<span id="cb42-507"><a href="#cb42-507" aria-hidden="true" tabindex="-1"></a><span class="in">------------------------------------------------------------------------------</span></span>
<span id="cb42-508"><a href="#cb42-508" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-509"><a href="#cb42-509" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-510"><a href="#cb42-510" aria-hidden="true" tabindex="-1"></a>So you can see that the two-step approach and the built-in approach now provide the same marginal effects. And since the official command estimates all coefficients simultaneously, the standard errors can be taken as correct (more on that later).</span>
<span id="cb42-511"><a href="#cb42-511" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-512"><a href="#cb42-512" aria-hidden="true" tabindex="-1"></a>So how can we correct for this with our predict program. Since there is nothing to prevent margins to obtain numerical derivatives across both equations, we need to modify the specification slighly. First, we create clone copies of all variables that enter the second stage: z_1 and y_2, and use them for the model estimation:</span>
<span id="cb42-513"><a href="#cb42-513" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-516"><a href="#cb42-516" aria-hidden="true" tabindex="-1"></a><span class="in">```{stata}</span></span>
<span id="cb42-517"><a href="#cb42-517" aria-hidden="true" tabindex="-1"></a><span class="in">clonevar c_other_inc = other_inc</span></span>
<span id="cb42-518"><a href="#cb42-518" aria-hidden="true" tabindex="-1"></a><span class="in">clonevar c_fem_educ  = fem_educ</span></span>
<span id="cb42-519"><a href="#cb42-519" aria-hidden="true" tabindex="-1"></a><span class="in">clonevar c_kids      = kids</span></span>
<span id="cb42-520"><a href="#cb42-520" aria-hidden="true" tabindex="-1"></a><span class="in">global  y2b c_other_inc</span></span>
<span id="cb42-521"><a href="#cb42-521" aria-hidden="true" tabindex="-1"></a><span class="in">global  z1b c_fem_educ c_kids </span></span>
<span id="cb42-522"><a href="#cb42-522" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-523"><a href="#cb42-523" aria-hidden="true" tabindex="-1"></a><span class="in">ml model lf myivprobit_2sls ($y1 = $z1  $y2 )  (theta:) ($y2b = $z1b $z2  ) (lnsigma:) , ///</span></span>
<span id="cb42-524"><a href="#cb42-524" aria-hidden="true" tabindex="-1"></a><span class="in">            technique(nr bhhh)   init(lnsigma:_cons = 2.81 ) maximize nolog</span></span>
<span id="cb42-525"><a href="#cb42-525" aria-hidden="true" tabindex="-1"></a><span class="in">adde local predict myivprobit_p                 </span></span>
<span id="cb42-526"><a href="#cb42-526" aria-hidden="true" tabindex="-1"></a><span class="in">est sto myivp   </span></span>
<span id="cb42-527"><a href="#cb42-527" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-528"><a href="#cb42-528" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-529"><a href="#cb42-529" aria-hidden="true" tabindex="-1"></a>The idea of using "clones" of the exogenous variables and endogenous one is to have access to the same information as the original data, but making sure they do not change when the original data changes.</span>
<span id="cb42-530"><a href="#cb42-530" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-531"><a href="#cb42-531" aria-hidden="true" tabindex="-1"></a>Marginal effects can be calculated as I did before, except that I now make it explicit to request marginal effects with respect to $z_1$ and $y_2$ only.</span>
<span id="cb42-532"><a href="#cb42-532" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-535"><a href="#cb42-535" aria-hidden="true" tabindex="-1"></a><span class="in">```{stata}</span></span>
<span id="cb42-536"><a href="#cb42-536" aria-hidden="true" tabindex="-1"></a><span class="in">est restore myivp       </span></span>
<span id="cb42-537"><a href="#cb42-537" aria-hidden="true" tabindex="-1"></a><span class="in">margins, dydx($z1 $y2) predict(pr1) force </span></span>
<span id="cb42-538"><a href="#cb42-538" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-539"><a href="#cb42-539" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-540"><a href="#cb42-540" aria-hidden="true" tabindex="-1"></a>And done!. We have been able to reproduce the second version, two-step, marginal effects for the instrumental variable probit model, that follows the two-step approach advocated by Prof. Wooldridge, and officially included in Stata 16 and above.</span>
<span id="cb42-541"><a href="#cb42-541" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-542"><a href="#cb42-542" aria-hidden="true" tabindex="-1"></a>There is only one last perky detail. If you look at the marginal effect standard errors I produce with the myivprobit command, and compare it with the marginal effects the ivprobit command produces, you will notice they are different. </span>
<span id="cb42-543"><a href="#cb42-543" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-544"><a href="#cb42-544" aria-hidden="true" tabindex="-1"></a>The reason for this was that, based on unofficial words from the developers, at the time:</span>
<span id="cb42-545"><a href="#cb42-545" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-546"><a href="#cb42-546" aria-hidden="true" tabindex="-1"></a><span class="at">&gt; the current formulation assumes $\rho$ and $\sigma$ to be constant, when standard errors are obtained. </span></span>
<span id="cb42-547"><a href="#cb42-547" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-548"><a href="#cb42-548" aria-hidden="true" tabindex="-1"></a>While this may seem incorrect, I understand the intuition behind this idea.</span>
<span id="cb42-549"><a href="#cb42-549" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-550"><a href="#cb42-550" aria-hidden="true" tabindex="-1"></a>If you recall the estimation of marginal effects from the structural equation, it is not affected by $\rho$ nor $\sigma$. Perhaps this was one of the reasons why the estimated standard errors (Nov2020) are so similar to the ones based on the "old" structural marginal effects.</span>
<span id="cb42-551"><a href="#cb42-551" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-552"><a href="#cb42-552" aria-hidden="true" tabindex="-1"></a>My own command, however, accounts for the uncertainty in these parameter. This also seems correct since two-step marginal procedures are expected to be less efficient than the Full Information counterparts.</span>
<span id="cb42-553"><a href="#cb42-553" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-554"><a href="#cb42-554" aria-hidden="true" tabindex="-1"></a>Of course, if you prefer to have a tie-breaker on which one is correct, I can use a Bootstrap procedure to produce the elusive standard errors. Basically, I'll use the manual two-step procedure, along with a 250 bootstrap repetitions, to report the results:</span>
<span id="cb42-555"><a href="#cb42-555" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-558"><a href="#cb42-558" aria-hidden="true" tabindex="-1"></a><span class="in">```{stata}</span></span>
<span id="cb42-559"><a href="#cb42-559" aria-hidden="true" tabindex="-1"></a><span class="in">program bs_ivprobit, eclass</span></span>
<span id="cb42-560"><a href="#cb42-560" aria-hidden="true" tabindex="-1"></a><span class="in">    reg $y2 $z1 $z2</span></span>
<span id="cb42-561"><a href="#cb42-561" aria-hidden="true" tabindex="-1"></a><span class="in">    capture drop u2</span></span>
<span id="cb42-562"><a href="#cb42-562" aria-hidden="true" tabindex="-1"></a><span class="in">    predict double u2, resid</span></span>
<span id="cb42-563"><a href="#cb42-563" aria-hidden="true" tabindex="-1"></a><span class="in">    probit $y1 $z1 $y2 u2</span></span>
<span id="cb42-564"><a href="#cb42-564" aria-hidden="true" tabindex="-1"></a><span class="in">    margins, dydx(*) predict(pr) nose post</span></span>
<span id="cb42-565"><a href="#cb42-565" aria-hidden="true" tabindex="-1"></a><span class="in">end</span></span>
<span id="cb42-566"><a href="#cb42-566" aria-hidden="true" tabindex="-1"></a><span class="in">bootstrap , reps(250) seed(1) nodots:bs_ivprobit</span></span>
<span id="cb42-567"><a href="#cb42-567" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-568"><a href="#cb42-568" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-569"><a href="#cb42-569" aria-hidden="true" tabindex="-1"></a>In this case, it seems that the bootstrap estimates seem to favor my version of marginal effects and standard errors!</span>
<span id="cb42-570"><a href="#cb42-570" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-571"><a href="#cb42-571" aria-hidden="true" tabindex="-1"></a><span class="fu">## One last change.</span></span>
<span id="cb42-572"><a href="#cb42-572" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-573"><a href="#cb42-573" aria-hidden="true" tabindex="-1"></a>Seems my guess was correct!. In March of 2021, Stata pushed another update to Stata16. They have now changed how SE are estimated after margins, which now coincides with the experiment I started with. </span>
<span id="cb42-574"><a href="#cb42-574" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-577"><a href="#cb42-577" aria-hidden="true" tabindex="-1"></a><span class="in">```{stata}</span></span>
<span id="cb42-578"><a href="#cb42-578" aria-hidden="true" tabindex="-1"></a><span class="in">ivprobit $y1  $z1 ($y2 = $z2), ml nolog</span></span>
<span id="cb42-579"><a href="#cb42-579" aria-hidden="true" tabindex="-1"></a><span class="in">margins, dydx(*) predict(pr)</span></span>
<span id="cb42-580"><a href="#cb42-580" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-581"><a href="#cb42-581" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-582"><a href="#cb42-582" aria-hidden="true" tabindex="-1"></a>So there is my small contribution to Stata!</span>
<span id="cb42-583"><a href="#cb42-583" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-584"><a href="#cb42-584" aria-hidden="true" tabindex="-1"></a><span class="fu">## Conclusion</span></span>
<span id="cb42-585"><a href="#cb42-585" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-586"><a href="#cb42-586" aria-hidden="true" tabindex="-1"></a>The command -ml- is a powerful tool that can be used to estimate single or multiple equation models, as long as the loglikelihood functions (and their inter-relations) can be properly defined.</span>
<span id="cb42-587"><a href="#cb42-587" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-588"><a href="#cb42-588" aria-hidden="true" tabindex="-1"></a>-margins- is also a very flexible command that can be easily combined with -ml- to expand the estimation of marginal effects for properly defined outcomes. While the command is flexible and relatively easy to use, these properties can also be double-edge swords, if one is not aware of the mechanics behind the actual estimation of partial effects.</span>
<span id="cb42-589"><a href="#cb42-589" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-590"><a href="#cb42-590" aria-hidden="true" tabindex="-1"></a>In my view, the original estimation of marginal effects after iv-probit was correct, but the changes it received in Stata 14.1 introduced what we could call a bug, that was based on solid Math. However, unless you dig deeper into what ivprobit tries to estimate, it would be difficult to say why that change produced undesirable results.</span>
<span id="cb42-591"><a href="#cb42-591" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-592"><a href="#cb42-592" aria-hidden="true" tabindex="-1"></a>The updates pushed in Stata 16 made the necesary corrections following my suggestions, and now produces correct partial effects (two-step like), even adopting my comment regarding standard errors. </span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->



</body></html>